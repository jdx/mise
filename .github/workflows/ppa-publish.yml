name: ppa-publish

on:
  release:
    types: [published]
  workflow_dispatch:
    inputs:
      distributions:
        description: "Ubuntu distributions to target (space-separated)"
        required: false
        default: "resolute"
        type: string
      use_serious_profile:
        description: 'Use the "serious" profile for optimized builds (LTO enabled)'
        required: false
        default: false
        type: boolean
      build_revision:
        description: "Build revision number (increment for packaging fixes of same version)"
        required: false
        default: "1"
        type: string
      version_suffix:
        description: "Version suffix for orig tarball (e.g., +ppa1) - use when tarball contents change"
        required: false
        default: ""
        type: string

env:
  DEBIAN_FRONTEND: noninteractive

jobs:
  publish-ppa:
    runs-on: ubuntu-latest
    environment: ppa-publishing
    timeout-minutes: 45

    steps:
      - name: Checkout repository
        uses: actions/checkout@34e114876b0b11c390a56381ad16ebd13914f8d5 # v4
        with:
          fetch-depth: 0

      - name: Set up environment variables
        run: |
          VERSION=$(./scripts/get-version.sh | sed 's/^v//')

          if [ "${{ github.event_name }}" = "release" ]; then
            DISTRIBUTIONS="resolute"
            BUILD_REVISION="1"
            VERSION_SUFFIX=""
          else
            DISTRIBUTIONS="${{ inputs.distributions }}"
            BUILD_REVISION="${{ inputs.build_revision || '1' }}"
            VERSION_SUFFIX="${{ inputs.version_suffix }}"
          fi

          # Apply version suffix (e.g., 2026.2.0 -> 2026.2.0+ppa1)
          VERSION="${VERSION}${VERSION_SUFFIX}"

          {
            echo "VERSION=${VERSION}"
            echo "DISTRIBUTIONS=${DISTRIBUTIONS}"
            echo "BUILD_REVISION=${BUILD_REVISION}"
            echo "PACKAGE_NAME=mise"
            echo "MAINTAINER_NAME=${{ vars.PPA_MAINTAINER_NAME || 'mise Release Bot' }}"
            echo "MAINTAINER_EMAIL=${{ vars.PPA_MAINTAINER_EMAIL || 'noreply@mise.jdx.dev' }}"
            echo "PPA_NAME=${{ vars.PPA_NAME || 'ppa:jdxcode/mise' }}"
          } >> "$GITHUB_ENV"

          # Set build profile
          if [ "${{ github.event_name }}" = "release" ] || [ "${{ inputs.use_serious_profile }}" = "true" ]; then
            echo "BUILD_PROFILE=serious" >> "$GITHUB_ENV"
          else
            echo "BUILD_PROFILE=release" >> "$GITHUB_ENV"
          fi

      - name: Install packaging dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y \
            devscripts \
            debhelper \
            dh-make \
            build-essential \
            git-buildpackage \
            dput \
            lintian \
            quilt \
            fakeroot \
            debian-keyring \
            gpg \
            libssl-dev \
            pkg-config

      - name: Set up Rust
        uses: dtolnay/rust-toolchain@stable
        with:
          toolchain: stable

      - name: Install mise
        run: |
          curl https://mise.run | sh
          echo "$HOME/.local/bin" >> "$GITHUB_PATH"
      - run: mise x wait-for-gh-rate-limit -- wait-for-gh-rate-limit
      - name: Install cargo-vendor
        run: mise use -g cargo-binstall cargo:cargo-vendor

      - name: Vendor Rust dependencies
        run: |
          mkdir -p .cargo
          cat > .cargo/config.toml << 'EOF'
          [source.crates-io]
          replace-with = "vendored-sources"

          [source.vendored-sources]
          directory = "vendor"
          EOF
          cargo vendor vendor/

          # Clear all vendor checksums â€” dpkg-source strips .o, .a, .git*, *.orig and
          # other files, which breaks cargo's checksum verification. With --frozen cargo
          # still enforces the lockfile, so integrity is maintained.
          for checksum in vendor/*/.cargo-checksum.json; do
            jq '.files = {}' "$checksum" > "$checksum.tmp" && mv "$checksum.tmp" "$checksum"
          done

      - name: Configure Git
        run: |
          git config --global user.name "${{ env.MAINTAINER_NAME }}"
          git config --global user.email "${{ env.MAINTAINER_EMAIL }}"

      - name: Import GPG key
        uses: crazy-max/ghaction-import-gpg@e89d40939c28e39f97cf32126055eeae86ba74ec # v6
        with:
          gpg_private_key: ${{ secrets.MISE_GPG_KEY }}
          git_user_signingkey: true
          git_commit_gpgsign: true
          trust_level: 5

      - name: Configure GPG for package signing
        run: |
          # List available keys
          echo "Available GPG keys:"
          gpg --list-secret-keys --with-colons

          # Get the key ID  
          KEY_ID=$(gpg --list-secret-keys --with-colons | grep '^sec:' | cut -d: -f5 | head -1)
          if [ -n "$KEY_ID" ]; then
            echo "Using GPG key: $KEY_ID"
            echo "DEBSIGN_KEYID=$KEY_ID" >> "$GITHUB_ENV"
            
            # Configure debsign to use this key specifically
            cat > ~/.devscripts << EOF
          DEBSIGN_KEYID=$KEY_ID
          DEBUILD_DPKG_BUILDPACKAGE_OPTS="-i -I -S -sa"
          DEBUILD_LINTIAN_OPTS="-i -I --show-overrides --profile ubuntu"
          DEBSIGN_PROGRAM=gpg
          EOF
            
            echo "devscripts configuration:"
            cat ~/.devscripts
            
            # Test that the key works for signing
            echo "Testing GPG signing..."
            echo "test" | gpg --clearsign --default-key "$KEY_ID" --armor || echo "Warning: GPG signing test failed"
            
          else
            echo "Error: No GPG key found"
            exit 1
          fi

      - name: Create source package for each distribution
        run: |
          # Create debian directory structure (native format - no orig tarball needed)
          mkdir -p debian/source

          echo "3.0 (native)" > debian/source/format

          # Create basic debian files
          cat > debian/control << EOF
          Source: ${PACKAGE_NAME}
          Section: utils
          Priority: optional
          Maintainer: ${MAINTAINER_NAME} <${MAINTAINER_EMAIL}>
          Build-Depends: debhelper-compat (= 13), rustc (>= 1.88), cargo, libssl-dev, pkgconf
          Standards-Version: 4.6.2
          Homepage: https://mise.jdx.dev
          Vcs-Git: https://github.com/jdx/mise.git
          Vcs-Browser: https://github.com/jdx/mise

          Package: ${PACKAGE_NAME}
          Architecture: any
          Depends: \${shlibs:Depends}, \${misc:Depends}
          Description: The front-end to your dev env
           mise is a development environment setup tool that handles runtime versions,
           environment variables, and tasks. It's a replacement for tools like nvm, rbenv,
           pyenv, etc. and works with any language.
          EOF

          # Determine target directory (release profile uses target/release/, others use target/<profile>/)
          if [ "${BUILD_PROFILE}" = "release" ]; then
            TARGET_DIR="target/release"
          else
            TARGET_DIR="target/${BUILD_PROFILE}"
          fi

          cat > debian/rules << EOF
          #!/usr/bin/make -f

          %:
          	dh \$@

          override_dh_auto_build:
          	cargo build --profile ${BUILD_PROFILE} --frozen --bin mise

          override_dh_auto_install:
          	mkdir -p debian/mise/usr/bin
          	cp ${TARGET_DIR}/mise debian/mise/usr/bin/
          	mkdir -p debian/mise/usr/share/man/man1
          	if [ -f man/man1/mise.1 ]; then cp man/man1/mise.1 debian/mise/usr/share/man/man1/; fi
          	mkdir -p debian/mise/usr/share/bash-completion/completions
          	if [ -f completions/mise.bash ]; then cp completions/mise.bash debian/mise/usr/share/bash-completion/completions/mise; fi
          	mkdir -p debian/mise/usr/share/zsh/site-functions
          	if [ -f completions/_mise ]; then cp completions/_mise debian/mise/usr/share/zsh/site-functions/; fi
          	mkdir -p debian/mise/usr/share/fish/vendor_completions.d
          	if [ -f completions/mise.fish ]; then cp completions/mise.fish debian/mise/usr/share/fish/vendor_completions.d/; fi
          	mkdir -p debian/mise/usr/lib/mise
          	echo 'message = "To update, run:\\n\\n  sudo apt update && sudo apt install --only-upgrade mise\\n"' > debian/mise/usr/lib/mise/mise-self-update-instructions.toml

          override_dh_auto_clean:
          	cargo clean || true
          EOF

          chmod +x debian/rules

          cat > debian/copyright << EOF
          Format: https://www.debian.org/doc/packaging-manuals/copyright-format/1.0/
          Upstream-Name: ${PACKAGE_NAME}
          Source: https://github.com/jdx/mise

          Files: *
          Copyright: 2023-2025 Jeff Dickey
          License: MIT

          License: MIT
           Permission is hereby granted, free of charge, to any person obtaining a
           copy of this software and associated documentation files (the "Software"),
           to deal in the Software without restriction, including without limitation
           the rights to use, copy, modify, merge, publish, distribute, sublicense,
           and/or sell copies of the Software, and to permit persons to whom the
           Software is furnished to do so, subject to the following conditions:
           .
           The above copyright notice and this permission notice shall be included
           in all copies or substantial portions of the Software.
           .
           THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
           OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
           MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
           IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
           CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
           TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
           SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
          EOF

          # Build source packages for each distribution
          for DIST in ${DISTRIBUTIONS}; do
            echo "Building source package for $DIST"

            # Create distribution-specific version (native format uses ~ instead of -)
            DIST_VERSION="${VERSION}~${DIST}${BUILD_REVISION}"
            
            # Create changelog
            cat > debian/changelog << EOF
          ${PACKAGE_NAME} (${DIST_VERSION}) ${DIST}; urgency=medium

            * New upstream release ${VERSION}

           -- ${MAINTAINER_NAME} <${MAINTAINER_EMAIL}>  $(date -R)
          EOF
            
            # Build source package (-d skips build-dep checks since we're only creating source package)
            # TODO: remove -d once GitHub runners use Ubuntu 26.04 with Rust 1.88+
            debuild -d
            
            # Move built packages
            mkdir -p "/tmp/packages"
            mv ../*"${DIST_VERSION}"*.dsc "/tmp/packages/"
            mv ../*"${DIST_VERSION}"*.tar.* "/tmp/packages/"
            mv ../*"${DIST_VERSION}"*.changes "/tmp/packages/"
            mv ../*"${DIST_VERSION}"*.buildinfo "/tmp/packages/" 2>/dev/null || true
            
            # Clean for next distribution
            rm -f ../mise_"${DIST_VERSION}"*
          done

      - name: Upload source packages to PPA
        run: |
          cd /tmp/packages

          # Configure dput
          cat > ~/.dput.cf << EOF
          [mise-ppa]
          fqdn = ppa.launchpad.net
          method = ftp
          incoming = ~${PPA_NAME#ppa:}/ubuntu/
          login = anonymous
          allow_unsigned_uploads = 0
          EOF

          # Upload each changes file
          for changes_file in *.changes; do
            echo "Uploading $changes_file to PPA..."
            dput mise-ppa "$changes_file"
          done
