min_usage_version "1.3"
name mise
bin mise
about "The front-end to your dev env"
long_about "mise manages dev tools, env vars, and runs tasks. https://github.com/jdx/mise"
usage "Usage: mise [OPTIONS] [TASK] [COMMAND]"
flag "-C --cd" help="Change directory before running command" global=#true {
    arg <DIR>
}
flag "-c --continue-on-error" help="Continue running tasks even if one fails" hide=#true
flag "-n --dry-run" help="Dry run, don't actually do anything" hide=#true
flag "-E --env" help="Set the environment for loading `mise.<ENV>.toml`" var=#true global=#true {
    arg <ENV>
}
flag "-f --force" help="Force the operation" hide=#true
flag "-i --interleave" help="Set the log output verbosity" hide=#true
flag "-j --jobs" help="How many jobs to run in parallel [default: 8]" global=#true {
    arg <JOBS>
}
flag "-p --prefix" hide=#true
flag --output {
    arg <OUTPUT>
}
flag "-P --profile" help="Set the profile (environment)" var=#true hide=#true global=#true {
    arg <PROFILE>
}
flag "-s --shell" hide=#true {
    arg <SHELL>
}
flag "-t --tool" help="Tool(s) to run in addition to what is in mise.toml files e.g.: node@20 python@3.10" var=#true hide=#true {
    arg <TOOL@VERSION>
}
flag --raw help="Read/write directly to stdin/stdout/stderr instead of by line" global=#true
flag --timings help="Shows elapsed time after each task completes" hide=#true {
    long_help "Shows elapsed time after each task completes\n\nDefault to always show with `MISE_TASK_TIMINGS=1`"
}
flag --no-config help="Do not load any config files" {
    long_help "Do not load any config files\n\nCan also use `MISE_NO_CONFIG=1`"
}
flag --no-timings help="Hides elapsed time after each task completes" hide=#true {
    long_help "Hides elapsed time after each task completes\n\nDefault to always hide with `MISE_TASK_TIMINGS=0`"
}
flag "-V --version" hide=#true
flag "-y --yes" help="Answer yes to all confirmation prompts" global=#true
flag --debug help="Sets log level to debug" hide=#true global=#true
flag --log-level hide=#true global=#true {
    arg <LEVEL> {
        choices trace debug info warning error
    }
}
flag "-q --quiet" help="Suppress non-error messages" global=#true
flag --silent help="Suppress all task output and mise non-error messages" global=#true
flag --trace help="Sets log level to trace" hide=#true global=#true
flag "-v --verbose" help="Show extra output (use -vv for even more)" var=#true global=#true count=#true
arg "[TASK]" help="Task to run" help_long="Task to run.\n\nShorthand for `mise task run <TASK>`." required=#false
arg "[TASK_ARGS]..." help="Task arguments" required=#false var=#true hide=#true
arg "[-- TASK_ARGS_LAST]..." required=#false var=#true hide=#true
cmd activate help="Initializes mise in the current shell session" {
    long_help "Initializes mise in the current shell session\n\nThis should go into your shell's rc file or login shell.\nOtherwise, it will only take effect in the current session.\n(e.g. ~/.zshrc, ~/.zprofile, ~/.zshenv, ~/.bashrc, ~/.bash_profile, ~/.profile, ~/.config/fish/config.fish, or $PROFILE for powershell)\n\nTypically, this can be added with something like the following:\n\n    echo 'eval \"$(mise activate zsh)\"' >> ~/.zshrc\n\nHowever, this requires that \"mise\" is in your PATH. If it is not, you need to\nspecify the full path like this:\n\n    echo 'eval \"$(/path/to/mise activate zsh)\"' >> ~/.zshrc\n\nCustomize status output with `status` settings."
    after_long_help "Examples:\n\n    $ eval \"$(mise activate bash)\"\n    $ eval \"$(mise activate zsh)\"\n    $ mise activate fish | source\n    $ execx($(mise activate xonsh))\n    $ (&mise activate pwsh) | Out-String | Invoke-Expression\n"
    flag "-s --shell" help="Shell type to generate the script for" hide=#true {
        arg <SHELL> {
            choices bash elvish fish nu xonsh zsh pwsh
        }
    }
    flag --status help="Show \"mise: <PLUGIN>@<VERSION>\" message when changing directories" hide=#true
    flag --shims help="Use shims instead of modifying PATH\nEffectively the same as:" {
        long_help "Use shims instead of modifying PATH\nEffectively the same as:\n\n    PATH=\"$HOME/.local/share/mise/shims:$PATH\"\n\n`mise activate --shims` does not support all the features of `mise activate`.\nSee https://mise.jdx.dev/dev-tools/shims.html#shims-vs-path for more information"
    }
    flag "-q --quiet" help="Suppress non-error messages"
    flag --no-hook-env help="Do not automatically call hook-env" {
        long_help "Do not automatically call hook-env\n\nThis can be helpful for debugging mise. If you run `eval \"$(mise activate --no-hook-env)\"`, then you can call `mise hook-env` manually which will output the env vars to stdout without actually modifying the environment. That way you can do things like `mise hook-env --trace` to get more information or just see the values that hook-env is outputting."
    }
    arg "[SHELL_TYPE]" help="Shell type to generate the script for" required=#false {
        choices bash elvish fish nu xonsh zsh pwsh
    }
}
cmd alias help="Manage aliases" {
    alias a
    alias aliases hide=#true
    flag "-p --plugin" help="filter aliases by plugin" {
        arg <PLUGIN>
    }
    flag --no-header help="Don't show table header"
    cmd get help="Show an alias for a plugin" {
        long_help "Show an alias for a plugin\n\nThis is the contents of an alias.<PLUGIN> entry in ~/.config/mise/config.toml"
        after_long_help "Examples:\n\n    $ mise alias get node lts-hydrogen\n    20.0.0\n"
        arg <PLUGIN> help="The plugin to show the alias for"
        arg <ALIAS> help="The alias to show"
    }
    cmd ls help="List aliases\nShows the aliases that can be specified.\nThese can come from user config or from plugins in `bin/list-aliases`." {
        alias list
        long_help "List aliases\nShows the aliases that can be specified.\nThese can come from user config or from plugins in `bin/list-aliases`.\n\nFor user config, aliases are defined like the following in `~/.config/mise/config.toml`:\n\n    [alias.node.versions]\n    lts = \"22.0.0\""
        after_long_help "Examples:\n\n    $ mise aliases\n    node  lts-jod      22\n"
        flag --no-header help="Don't show table header"
        arg "[TOOL]" help="Show aliases for <TOOL>" required=#false
    }
    cmd set help="Add/update an alias for a plugin" {
        alias add create
        long_help "Add/update an alias for a plugin\n\nThis modifies the contents of ~/.config/mise/config.toml"
        after_long_help "Examples:\n\n    $ mise alias set node lts-jod 22.0.0\n"
        arg <PLUGIN> help="The plugin to set the alias for"
        arg <ALIAS> help="The alias to set"
        arg <VALUE> help="The value to set the alias to"
    }
    cmd unset help="Clears an alias for a plugin" {
        alias rm remove delete del
        long_help "Clears an alias for a plugin\n\nThis modifies the contents of ~/.config/mise/config.toml"
        after_long_help "Examples:\n\n    $ mise alias unset node lts-jod\n"
        arg <PLUGIN> help="The plugin to remove the alias from"
        arg <ALIAS> help="The alias to remove"
    }
}
cmd asdf hide=#true help="[internal] simulates asdf for plugins that call \"asdf\" internally" {
    arg "[ARGS]..." help="all arguments" required=#false double_dash=automatic var=#true
}
cmd backends help="Manage backends" {
    alias b
    alias backend backend-list hide=#true
    cmd ls help="List built-in backends" {
        alias list
        after_long_help "Examples:\n\n    $ mise backends ls\n    aqua\n    asdf\n    cargo\n    core\n    dotnet\n    gem\n    go\n    npm\n    pipx\n    spm\n    ubi\n    vfox\n"
    }
}
cmd bin-paths help="List all the active runtime bin paths" {
    arg "[TOOL@VERSION]..." help="Tool(s) to look up\ne.g.: ruby@3" required=#false var=#true
}
cmd cache help="Manage the mise cache" {
    long_help "Manage the mise cache\n\nRun `mise cache` with no args to view the current cache directory."
    cmd clear help="Deletes all cache files in mise" {
        alias c
        alias clean hide=#true
        flag --outdate help="Mark all cache files as old" hide=#true
        arg "[PLUGIN]..." help="Plugin(s) to clear cache for e.g.: node, python" required=#false var=#true
    }
    cmd prune help="Removes stale mise cache files" {
        alias p
        long_help "Removes stale mise cache files\n\nBy default, this command will remove files that have not been accessed in 30 days.\nChange this with the MISE_CACHE_PRUNE_AGE environment variable."
        flag --dry-run help="Just show what would be pruned"
        flag "-v --verbose" help="Show pruned files" var=#true count=#true
        arg "[PLUGIN]..." help="Plugin(s) to clear cache for e.g.: node, python" required=#false var=#true
    }
}
cmd completion help="Generate shell completions" {
    alias complete completions hide=#true
    after_long_help "Examples:\n\n    $ mise completion bash > /etc/bash_completion.d/mise\n    $ mise completion zsh  > /usr/local/share/zsh/site-functions/_mise\n    $ mise completion fish > ~/.config/fish/completions/mise.fish\n"
    flag "-s --shell" help="Shell type to generate completions for" hide=#true {
        arg <SHELL_TYPE> {
            choices bash fish zsh
        }
    }
    flag --usage help="Always use usage for completions.\nCurrently, usage is the default for fish and bash but not zsh since it has a few quirks\nto work out first." hide=#true {
        long_help "Always use usage for completions.\nCurrently, usage is the default for fish and bash but not zsh since it has a few quirks\nto work out first.\n\nThis requires the `usage` CLI to be installed.\nhttps://usage.jdx.dev"
    }
    flag --include-bash-completion-lib help="Include the bash completion library in the bash completion script" {
        long_help "Include the bash completion library in the bash completion script\n\nThis is required for completions to work in bash, but it is not included by default\nyou may source it separately or enable this flag to include it in the script."
    }
    arg "[SHELL]" help="Shell type to generate completions for" required=#false {
        choices bash fish zsh
    }
}
cmd config help="Manage config files" {
    alias cfg
    alias toml hide=#true
    after_long_help "Examples:\n\n    $ mise config ls\n    Path                        Tools\n    ~/.config/mise/config.toml  pitchfork\n    ~/src/mise/mise.toml        actionlint, bun, cargo-binstall, cargo:cargo-edit, cargo:cargo-insta\n"
    flag --no-header help="Do not print table header"
    flag --tracked-configs help="List all tracked config files"
    flag "-J --json" help="Output in JSON format"
    cmd generate help="[experimental] Generate a mise.toml file" {
        alias g
        after_long_help "Examples:\n\n    $ mise cf generate > mise.toml\n    $ mise cf generate --output=mise.toml\n"
        flag "-t --tool-versions" help="Path to a .tool-versions file to import tools from" {
            arg <TOOL_VERSIONS>
        }
        flag "-o --output" help="Output to file instead of stdout" {
            arg <OUTPUT>
        }
    }
    cmd get help="Display the value of a setting in a mise.toml file" {
        after_long_help "Examples:\n\n    $ mise toml get tools.python\n    3.12\n"
        flag "-f --file" help="The path to the mise.toml file to edit" {
            long_help "The path to the mise.toml file to edit\n\nIf not provided, the nearest mise.toml file will be used"
            arg <FILE>
        }
        arg "[KEY]" help="The path of the config to display" required=#false
    }
    cmd ls help="List config files currently in use" {
        alias list
        after_long_help "Examples:\n\n    $ mise config ls\n    Path                        Tools\n    ~/.config/mise/config.toml  pitchfork\n    ~/src/mise/mise.toml        actionlint, bun, cargo-binstall, cargo:cargo-edit, cargo:cargo-insta\n"
        flag --no-header help="Do not print table header"
        flag --tracked-configs help="List all tracked config files"
        flag "-J --json" help="Output in JSON format"
    }
    cmd set help="Set the value of a setting in a mise.toml file" {
        after_long_help "Examples:\n\n    $ mise config set tools.python 3.12\n    $ mise config set settings.always_keep_download true\n    $ mise config set env.TEST_ENV_VAR ABC\n    $ mise config set settings.disable_tools --type list node,rust\n\n    # Type for `settings` is inferred\n    $ mise config set settings.jobs 4\n"
        flag "-f --file" help="The path to the mise.toml file to edit" {
            long_help "The path to the mise.toml file to edit\n\nIf not provided, the nearest mise.toml file will be used"
            arg <FILE>
        }
        flag "-t --type" {
            arg <TYPE> {
                choices infer string integer float bool list
            }
        }
        arg <KEY> help="The path of the config to display"
        arg <VALUE> help="The value to set the key to"
    }
}
cmd current hide=#true help="Shows current active and installed runtime versions" {
    long_help "Shows current active and installed runtime versions\n\nThis is similar to `mise ls --current`, but this only shows the runtime\nand/or version. It's designed to fit into scripts more easily."
    after_long_help "Examples:\n\n    # outputs `.tool-versions` compatible format\n    $ mise current\n    python 3.11.0 3.10.0\n    shfmt 3.6.0\n    shellcheck 0.9.0\n    node 20.0.0\n\n    $ mise current node\n    20.0.0\n\n    # can output multiple versions\n    $ mise current python\n    3.11.0 3.10.0\n"
    arg "[PLUGIN]" help="Plugin to show versions of e.g.: ruby, node, cargo:eza, npm:prettier, etc" required=#false
}
cmd deactivate help="Disable mise for current shell session" {
    long_help "Disable mise for current shell session\n\nThis can be used to temporarily disable mise in a shell session."
    after_long_help "Examples:\n\n    $ mise deactivate\n"
}
cmd direnv hide=#true help="Output direnv function to use mise inside direnv" {
    long_help "Output direnv function to use mise inside direnv\n\nSee https://mise.jdx.dev/direnv.html for more information\n\nBecause this generates the idiomatic files based on currently installed plugins,\nyou should run this command after installing new plugins. Otherwise\ndirenv may not know to update environment variables when idiomatic file versions change."
    cmd envrc hide=#true help="[internal] This is an internal command that writes an envrc file\nfor direnv to consume."
    cmd exec hide=#true help="[internal] This is an internal command that writes an envrc file\nfor direnv to consume."
    cmd activate hide=#true help="Output direnv function to use mise inside direnv" {
        long_help "Output direnv function to use mise inside direnv\n\nSee https://mise.jdx.dev/direnv.html for more information\n\nBecause this generates the idiomatic files based on currently installed plugins,\nyou should run this command after installing new plugins. Otherwise\ndirenv may not know to update environment variables when idiomatic file versions change."
        after_long_help "Examples:\n\n    $ mise direnv activate > ~/.config/direnv/lib/use_mise.sh\n    $ echo 'use mise' > .envrc\n    $ direnv allow\n"
    }
}
cmd doctor help="Check mise installation for possible problems" {
    alias dr
    after_long_help "Examples:\n\n    $ mise doctor\n    [WARN] plugin node is not installed\n"
    flag "-J --json"
    cmd path help="Print the current PATH entries mise is providing" {
        alias paths hide=#true
        after_long_help "Examples:\n\n    Get the current PATH entries mise is providing\n    $ mise path\n    /home/user/.local/share/mise/installs/node/24.0.0/bin\n    /home/user/.local/share/mise/installs/rust/1.90.0/bin\n    /home/user/.local/share/mise/installs/python/3.10.0/bin\n"
        flag "-f --full" help="Print all entries including those not provided by mise"
    }
}
cmd en help="[experimental] starts a new shell with the mise environment built from the current configuration" {
    long_help "[experimental] starts a new shell with the mise environment built from the current configuration\n\nThis is an alternative to `mise activate` that allows you to explicitly start a mise session.\nIt will have the tools and environment variables in the configs loaded.\nNote that changing directories will not update the mise environment."
    after_long_help "Examples:\n\n    $ mise en .\n    $ node -v\n    v20.0.0\n\n    Skip loading bashrc:\n    $ mise en -s \"bash --norc\"\n\n    Skip loading zshrc:\n    $ mise en -s \"zsh -f\"\n"
    flag "-s --shell" help="Shell to start" {
        long_help "Shell to start\n\nDefaults to $SHELL"
        arg <SHELL>
    }
    arg "[DIR]" help="Directory to start the shell in" required=#false default=.
}
cmd env help="Exports env vars to activate mise a single time" {
    alias e
    long_help "Exports env vars to activate mise a single time\n\nUse this if you don't want to permanently install mise. It's not necessary to\nuse this if you have `mise activate` in your shell rc file."
    after_long_help "Examples:\n\n    $ eval \"$(mise env -s bash)\"\n    $ eval \"$(mise env -s zsh)\"\n    $ mise env -s fish | source\n    $ execx($(mise env -s xonsh))\n"
    flag "-J --json" help="Output in JSON format"
    flag --json-extended help="Output in JSON format with additional information (source, tool)"
    flag "-D --dotenv" help="Output in dotenv format"
    flag "-s --shell" help="Shell type to generate environment variables for" {
        arg <SHELL> {
            choices bash elvish fish nu xonsh zsh pwsh
        }
    }
    arg "[TOOL@VERSION]..." help="Tool(s) to use" required=#false var=#true
}
cmd exec help="Execute a command with tool(s) set" {
    alias x
    long_help "Execute a command with tool(s) set\n\nuse this to avoid modifying the shell session or running ad-hoc commands with mise tools set.\n\nTools will be loaded from mise.toml, though they can be overridden with <RUNTIME> args\nNote that only the plugin specified will be overridden, so if a `mise.toml` file\nincludes \"node 20\" but you run `mise exec python@3.11`; it will still load node@20.\n\nThe \"--\" separates runtimes from the commands to pass along to the subprocess."
    after_long_help "Examples:\n\n    $ mise exec node@20 -- node ./app.js  # launch app.js using node-20.x\n    $ mise x node@20 -- node ./app.js     # shorter alias\n\n    # Specify command as a string:\n    $ mise exec node@20 python@3.11 --command \"node -v && python -V\"\n\n    # Run a command in a different directory:\n    $ mise x -C /path/to/project node@20 -- node ./app.js\n"
    flag "-c --command" help="Command string to execute" {
        arg <C>
    }
    flag "-j --jobs" help="Number of jobs to run in parallel\n[default: 4]" {
        arg <JOBS>
    }
    flag --raw help="Directly pipe stdin/stdout/stderr from plugin to user Sets --jobs=1"
    arg "[TOOL@VERSION]..." help="Tool(s) to start e.g.: node@20 python@3.10" required=#false var=#true
    arg "[-- COMMAND]..." help="Command string to execute (same as --command)" required=#false var=#true
}
cmd fmt help="Formats mise.toml" {
    long_help "Formats mise.toml\n\nSorts keys and cleans up whitespace in mise.toml"
    after_long_help "Examples:\n\n    $ mise fmt\n"
    flag "-a --all" help="Format all files from the current directory"
}
cmd generate subcommand_required=#true help="[experimental] Generate files for various tools/services" {
    alias gen
    alias g hide=#true
    cmd bootstrap help="[experimental] Generate a script to download+execute mise" {
        long_help "[experimental] Generate a script to download+execute mise\n\nThis is designed to be used in a project where contributors may not have mise installed."
        after_long_help "Examples:\n\n    $ mise generate bootstrap >./bin/mise\n    $ chmod +x ./bin/mise\n    $ ./bin/mise install – automatically downloads mise to .mise if not already installed\n"
        flag "-l --localize" help="Sandboxes mise internal directories like MISE_DATA_DIR and MISE_CACHE_DIR into a `.mise` directory in the project" {
            long_help "Sandboxes mise internal directories like MISE_DATA_DIR and MISE_CACHE_DIR into a `.mise` directory in the project\n\nThis is necessary if users may use a different version of mise outside the project."
        }
        flag --localized-dir help="Directory to put localized data into" {
            arg <LOCALIZED_DIR>
        }
        flag "-V --version" help="Specify mise version to fetch" {
            arg <VERSION>
        }
        flag "-w --write" help="instead of outputting the script to stdout, write to a file and make it executable" {
            arg <WRITE>
        }
    }
    cmd config help="[experimental] Generate a mise.toml file" {
        alias g
        after_long_help "Examples:\n\n    $ mise cf generate > mise.toml\n    $ mise cf generate --output=mise.toml\n"
        flag "-t --tool-versions" help="Path to a .tool-versions file to import tools from" {
            arg <TOOL_VERSIONS>
        }
        flag "-o --output" help="Output to file instead of stdout" {
            arg <OUTPUT>
        }
    }
    cmd devcontainer help="[experimental] Generate a devcontainer to execute mise" {
        after_long_help "Examples:\n\n    $ mise generate devcontainer\n"
        flag "-n --name" help="The name of the devcontainer" {
            arg <NAME>
        }
        flag "-i --image" help="The image to use for the devcontainer" {
            arg <IMAGE>
        }
        flag "-m --mount-mise-data" help="Bind the mise-data-volume to the devcontainer"
        flag "-w --write" help="write to .devcontainer/devcontainer.json"
    }
    cmd git-pre-commit help="[experimental] Generate a git pre-commit hook" {
        alias pre-commit
        long_help "[experimental] Generate a git pre-commit hook\n\nThis command generates a git pre-commit hook that runs a mise task like `mise run pre-commit`\nwhen you commit changes to your repository.\n\nStaged files are passed to the task as `STAGED`."
        after_long_help "Examples:\n\n    $ mise generate git-pre-commit --write --task=pre-commit\n    $ git commit -m \"feat: add new feature\" # runs `mise run pre-commit`\n"
        flag --hook help="Which hook to generate (saves to .git/hooks/$hook)" {
            arg <HOOK>
        }
        flag "-t --task" help="The task to run when the pre-commit hook is triggered" {
            arg <TASK>
        }
        flag "-w --write" help="write to .git/hooks/pre-commit and make it executable"
    }
    cmd github-action help="[experimental] Generate a GitHub Action workflow file" {
        long_help "[experimental] Generate a GitHub Action workflow file\n\nThis command generates a GitHub Action workflow file that runs a mise task like `mise run ci`\nwhen you push changes to your repository."
        after_long_help "Examples:\n\n    $ mise generate github-action --write --task=ci\n    $ git commit -m \"feat: add new feature\"\n    $ git push # runs `mise run ci` on GitHub\n"
        flag --name help="the name of the workflow to generate" {
            arg <NAME>
        }
        flag "-t --task" help="The task to run when the workflow is triggered" {
            arg <TASK>
        }
        flag "-w --write" help="write to .github/workflows/$name.yml"
    }
    cmd task-docs help="Generate documentation for tasks in a project" {
        after_long_help "Examples:\n\n    $ mise generate task-docs\n"
        flag "-I --index" help="write only an index of tasks, intended for use with `--multi`"
        flag "-i --inject" help="inserts the documentation into an existing file" {
            long_help "inserts the documentation into an existing file\n\nThis will look for a special comment, <!-- mise-tasks -->, and replace it with the generated documentation.\nIt will replace everything between the comment and the next comment, <!-- /mise-tasks --> so it can be\nrun multiple times on the same file to update the documentation."
        }
        flag "-m --multi" help="render each task as a separate document, requires `--output` to be a directory"
        flag "-o --output" help="writes the generated docs to a file/directory" {
            arg <OUTPUT>
        }
        flag "-r --root" help="root directory to search for tasks" {
            arg <ROOT>
        }
        flag "-s --style" {
            arg <STYLE> {
                choices simple detailed
            }
        }
    }
    cmd task-stubs help="[experimental] Generates shims to run mise tasks" {
        long_help "[experimental] Generates shims to run mise tasks\n\nBy default, this will build shims like ./bin/<task>. These can be paired with `mise generate bootstrap`\nso contributors to a project can execute mise tasks without installing mise into their system."
        after_long_help "Examples:\n\n    $ mise task add test -- echo 'running tests'\n    $ mise generate task-stubs\n    $ ./bin/test\n    running tests\n"
        flag "-m --mise-bin" help="Path to a mise bin to use when running the task stub." {
            long_help "Path to a mise bin to use when running the task stub.\n\nUse `--mise-bin=./bin/mise` to use a mise bin generated from `mise generate bootstrap`"
            arg <MISE_BIN>
        }
        flag "-d --dir" help="Directory to create task stubs inside of" {
            arg <DIR>
        }
    }
}
cmd global hide=#true help="Sets/gets the global tool version(s)" {
    long_help "Sets/gets the global tool version(s)\n\nDisplays the contents of global config after writing.\nThe file is `$HOME/.config/mise/config.toml` by default. It can be changed with `$MISE_GLOBAL_CONFIG_FILE`.\nIf `$MISE_GLOBAL_CONFIG_FILE` is set to anything that ends in `.toml`, it will be parsed as `mise.toml`.\nOtherwise, it will be parsed as a `.tool-versions` file.\n\nUse MISE_ASDF_COMPAT=1 to default the global config to ~/.tool-versions\n\nUse `mise local` to set a tool version locally in the current directory."
    after_long_help "Examples:\n    # set the current version of node to 20.x\n    # will use a fuzzy version (e.g.: 20) in .tool-versions file\n    $ mise global --fuzzy node@20\n\n    # set the current version of node to 20.x\n    # will use a precise version (e.g.: 20.0.0) in .tool-versions file\n    $ mise global --pin node@20\n\n    # show the current version of node in ~/.tool-versions\n    $ mise global node\n    20.0.0\n"
    flag --pin help="Save exact version to `~/.tool-versions`\ne.g.: `mise global --pin node@20` will save `node 20.0.0` to ~/.tool-versions"
    flag --fuzzy help="Save fuzzy version to `~/.tool-versions`\ne.g.: `mise global --fuzzy node@20` will save `node 20` to ~/.tool-versions\nthis is the default behavior unless MISE_ASDF_COMPAT=1"
    flag --remove help="Remove the plugin(s) from ~/.tool-versions" var=#true {
        arg <PLUGIN>
    }
    flag --path help="Get the path of the global config file"
    arg "[TOOL@VERSION]..." help="Tool(s) to add to .tool-versions\ne.g.: node@20\nIf this is a single tool with no version, the current value of the global\n.tool-versions will be displayed" required=#false var=#true
}
cmd hook-env hide=#true help="[internal] called by activate hook to update env vars directory change" {
    flag "-s --shell" help="Shell type to generate script for" {
        arg <SHELL> {
            choices bash elvish fish nu xonsh zsh pwsh
        }
    }
    flag "-f --force" help="Skip early exit check"
    flag --status help="Show \"mise: <PLUGIN>@<VERSION>\" message when changing directories" hide=#true
    flag "-q --quiet" help="Hide warnings such as when a tool is not installed"
}
cmd hook-not-found hide=#true help="[internal] called by shell when a command is not found" {
    flag "-s --shell" help="Shell type to generate script for" {
        arg <SHELL> {
            choices bash elvish fish nu xonsh zsh pwsh
        }
    }
    arg <BIN> help="Attempted bin to run"
}
cmd implode help="Removes mise CLI and all related data" {
    long_help "Removes mise CLI and all related data\n\nSkips config directory by default."
    flag --config help="Also remove config directory"
    flag "-n --dry-run" help="List directories that would be removed without actually removing them"
}
cmd install help="Install a tool version" {
    alias i
    long_help "Install a tool version\n\nInstalls a tool version to `~/.local/share/mise/installs/<PLUGIN>/<VERSION>`\nInstalling alone will not activate the tools so they won't be in PATH.\nTo install and/or activate in one command, use `mise use` which will create a `mise.toml` file\nin the current directory to activate this tool when inside the directory.\nAlternatively, run `mise exec <TOOL>@<VERSION> -- <COMMAND>` to execute a tool without creating config files.\n\nTools will be installed in parallel. To disable, set `--jobs=1` or `MISE_JOBS=1`"
    after_long_help "Examples:\n\n    $ mise install node@20.0.0  # install specific node version\n    $ mise install node@20      # install fuzzy node version\n    $ mise install node         # install version specified in mise.toml\n    $ mise install              # installs everything specified in mise.toml\n"
    flag "-f --force" help="Force reinstall even if already installed"
    flag "-j --jobs" help="Number of jobs to run in parallel\n[default: 4]" {
        arg <JOBS>
    }
    flag --raw help="Directly pipe stdin/stdout/stderr from plugin to user Sets --jobs=1"
    flag "-v --verbose" help="Show installation output" var=#true count=#true {
        long_help "Show installation output\n\nThis argument will print plugin output such as download, configuration, and compilation output."
    }
    arg "[TOOL@VERSION]..." help="Tool(s) to install e.g.: node@20" required=#false var=#true
}
cmd install-into help="Install a tool version to a specific path" {
    long_help "Install a tool version to a specific path\n\nUsed for building a tool to a directory for use outside of mise"
    after_long_help "Examples:\n\n    # install node@20.0.0 into ./mynode\n    $ mise install-into node@20.0.0 ./mynode && ./mynode/bin/node -v\n    20.0.0\n"
    arg <TOOL@VERSION> help="Tool to install e.g.: node@20"
    arg <PATH> help="Path to install the tool into"
}
cmd latest help="Gets the latest available version for a plugin" {
    long_help "Gets the latest available version for a plugin\n\nSupports prefixes such as `node@20` to get the latest version of node 20."
    after_long_help "Examples:\n\n    $ mise latest node@20  # get the latest version of node 20\n    20.0.0\n\n    $ mise latest node     # get the latest stable version of node\n    20.0.0\n"
    flag "-i --installed" help="Show latest installed instead of available version"
    arg <TOOL@VERSION> help="Tool to get the latest version of"
    arg "[ASDF_VERSION]" help="The version prefix to use when querying the latest version same as the first argument after the \"@\" used for asdf compatibility" required=#false hide=#true
}
cmd link help="Symlinks a tool version into mise" {
    alias ln
    long_help "Symlinks a tool version into mise\n\nUse this for adding installs either custom compiled outside mise or built with a different tool."
    after_long_help "Examples:\n\n    # build node-20.0.0 with node-build and link it into mise\n    $ node-build 20.0.0 ~/.nodes/20.0.0\n    $ mise link node@20.0.0 ~/.nodes/20.0.0\n\n    # have mise use the python version provided by Homebrew\n    $ brew install node\n    $ mise link node@brew $(brew --prefix node)\n    $ mise use node@brew\n"
    flag "-f --force" help="Overwrite an existing tool version if it exists"
    arg <TOOL@VERSION> help="Tool name and version to create a symlink for"
    arg <PATH> help="The local path to the tool version\ne.g.: ~/.nvm/versions/node/v20.0.0"
}
cmd local hide=#true help="Sets/gets tool version in local .tool-versions or mise.toml" {
    alias l hide=#true
    long_help "Sets/gets tool version in local .tool-versions or mise.toml\n\nUse this to set a tool's version when within a directory\nUse `mise global` to set a tool version globally\nThis uses `.tool-version` by default unless there is a `mise.toml` file or if `MISE_USE_TOML`\nis set. A future v2 release of mise will default to using `mise.toml`."
    after_long_help "Examples:\n    # set the current version of node to 20.x for the current directory\n    # will use a precise version (e.g.: 20.0.0) in .tool-versions file\n    $ mise local node@20\n\n    # set node to 20.x for the current project (recurses up to find .tool-versions)\n    $ mise local -p node@20\n\n    # set the current version of node to 20.x for the current directory\n    # will use a fuzzy version (e.g.: 20) in .tool-versions file\n    $ mise local --fuzzy node@20\n\n    # removes node from .tool-versions\n    $ mise local --remove=node\n\n    # show the current version of node in .tool-versions\n    $ mise local node\n    20.0.0\n"
    flag "-p --parent" help="Recurse up to find a .tool-versions file rather than using the current directory only\nby default this command will only set the tool in the current directory (\"$PWD/.tool-versions\")"
    flag --pin help="Save exact version to `.tool-versions`\ne.g.: `mise local --pin node@20` will save `node 20.0.0` to .tool-versions"
    flag --fuzzy help="Save fuzzy version to `.tool-versions` e.g.: `mise local --fuzzy node@20` will save `node 20` to .tool-versions This is the default behavior unless MISE_ASDF_COMPAT=1"
    flag --remove help="Remove the plugin(s) from .tool-versions" var=#true {
        arg <PLUGIN>
    }
    flag --path help="Get the path of the config file"
    arg "[TOOL@VERSION]..." help="Tool(s) to add to .tool-versions/mise.toml\ne.g.: node@20\nif this is a single tool with no version,\nthe current value of .tool-versions/mise.toml will be displayed" required=#false var=#true
}
cmd ls help="List installed and active tool versions" {
    alias list
    long_help "List installed and active tool versions\n\nThis command lists tools that mise \"knows about\".\nThese may be tools that are currently installed, or those\nthat are in a config file (active) but may or may not be installed.\n\nIt's a useful command to get the current state of your tools."
    after_long_help "Examples:\n\n    $ mise ls\n    node    20.0.0 ~/src/myapp/.tool-versions latest\n    python  3.11.0 ~/.tool-versions           3.10\n    python  3.10.0\n\n    $ mise ls --current\n    node    20.0.0 ~/src/myapp/.tool-versions 20\n    python  3.11.0 ~/.tool-versions           3.11.0\n\n    $ mise ls --json\n    {\n      \"node\": [\n        {\n          \"version\": \"20.0.0\",\n          \"install_path\": \"/Users/jdx/.mise/installs/node/20.0.0\",\n          \"source\": {\n            \"type\": \"mise.toml\",\n            \"path\": \"/Users/jdx/mise.toml\"\n          }\n        }\n      ],\n      \"python\": [...]\n    }\n"
    flag "-p --plugin" hide=#true {
        arg <TOOL_FLAG>
    }
    flag "-c --current" help="Only show tool versions currently specified in a mise.toml"
    flag "-g --global" help="Only show tool versions currently specified in the global mise.toml"
    flag "-i --installed" help="Only show tool versions that are installed (Hides tools defined in mise.toml but not installed)"
    flag "-o --offline" help="Don't fetch information such as outdated versions"
    flag --outdated help="Display whether a version is outdated"
    flag "-J --json" help="Output in JSON format"
    flag "-m --missing" help="Display missing tool versions"
    flag --prefix help="Display versions matching this prefix" {
        arg <PREFIX>
    }
    flag --prunable help="List only tools that can be pruned with `mise prune`"
    flag --no-header help="Don't display headers"
    arg "[INSTALLED_TOOL]..." help="Only show tool versions from [TOOL]" required=#false var=#true
}
cmd ls-remote help="List runtime versions available for install." {
    alias list-all list-remote hide=#true
    long_help "List runtime versions available for install.\n\nNote that the results may be cached, run `mise cache clean` to clear the cache and get fresh results."
    after_long_help "Examples:\n\n    $ mise ls-remote node\n    18.0.0\n    20.0.0\n\n    $ mise ls-remote node@20\n    20.0.0\n    20.1.0\n\n    $ mise ls-remote node 20\n    20.0.0\n    20.1.0\n"
    flag --all help="Show all installed plugins and versions"
    arg "[TOOL@VERSION]" help="Tool to get versions for" required=#false
    arg "[PREFIX]" help="The version prefix to use when querying the latest version\nsame as the first argument after the \"@\"" required=#false
}
cmd outdated help="Shows outdated tool versions" {
    long_help "Shows outdated tool versions\n\nSee `mise upgrade` to upgrade these versions."
    after_long_help "Examples:\n\n    $ mise outdated\n    Plugin  Requested  Current  Latest\n    python  3.11       3.11.0   3.11.1\n    node    20         20.0.0   20.1.0\n\n    $ mise outdated node\n    Plugin  Requested  Current  Latest\n    node    20         20.0.0   20.1.0\n\n    $ mise outdated --json\n    {\"python\": {\"requested\": \"3.11\", \"current\": \"3.11.0\", \"latest\": \"3.11.1\"}, ...}\n"
    flag "-l --bump" help="Compares against the latest versions available, not what matches the current config" {
        long_help "Compares against the latest versions available, not what matches the current config\n\nFor example, if you have `node = \"20\"` in your config by default `mise outdated` will only\nshow other 20.x versions, not 21.x or 22.x versions.\n\nUsing this flag, if there are 21.x or newer versions it will display those instead of 20.x."
    }
    flag "-J --json" help="Output in JSON format"
    flag --no-header help="Don't show table header"
    arg "[TOOL@VERSION]..." help="Tool(s) to show outdated versions for\ne.g.: node@20 python@3.10\nIf not specified, all tools in global and local configs will be shown" required=#false var=#true
}
cmd plugins help="Manage plugins" {
    alias p
    alias plugin plugin-list hide=#true
    flag "-a --all" help="list all available remote plugins" hide=#true {
        long_help "list all available remote plugins\n\nsame as `mise plugins ls-remote`"
    }
    flag "-c --core" help="The built-in plugins only\nNormally these are not shown"
    flag --user help="List installed plugins" {
        long_help "List installed plugins\n\nThis is the default behavior but can be used with --core\nto show core and user plugins"
    }
    flag "-u --urls" help="Show the git url for each plugin\ne.g.: https://github.com/asdf-vm/asdf-nodejs.git"
    flag --refs help="Show the git refs for each plugin\ne.g.: main 1234abc" hide=#true
    cmd install help="Install a plugin" {
        alias i a add
        long_help "Install a plugin\n\nnote that mise automatically can install plugins when you install a tool\ne.g.: `mise install node@20` will autoinstall the node plugin\n\nThis behavior can be modified in ~/.config/mise/config.toml"
        after_long_help "Examples:\n\n    # install the node via shorthand\n    $ mise plugins install node\n\n    # install the node plugin using a specific git url\n    $ mise plugins install node https://github.com/mise-plugins/rtx-nodejs.git\n\n    # install the node plugin using the git url only\n    # (node is inferred from the url)\n    $ mise plugins install https://github.com/mise-plugins/rtx-nodejs.git\n\n    # install the node plugin using a specific ref\n    $ mise plugins install node https://github.com/mise-plugins/rtx-nodejs.git#v1.0.0\n"
        flag "-f --force" help="Reinstall even if plugin exists"
        flag "-a --all" help="Install all missing plugins\nThis will only install plugins that have matching shorthands.\ni.e.: they don't need the full git repo url"
        flag "-v --verbose" help="Show installation output" var=#true count=#true
        arg "[NEW_PLUGIN]" help="The name of the plugin to install\ne.g.: node, ruby\nCan specify multiple plugins: `mise plugins install node ruby python`" required=#false
        arg "[GIT_URL]" help="The git url of the plugin" required=#false
        arg "[REST]..." required=#false var=#true hide=#true
    }
    cmd link help="Symlinks a plugin into mise" {
        alias ln
        long_help "Symlinks a plugin into mise\n\nThis is used for developing a plugin."
        after_long_help "Examples:\n\n    # essentially just `ln -s ./mise-node ~/.local/share/mise/plugins/node`\n    $ mise plugins link node ./mise-node\n\n    # infer plugin name as \"node\"\n    $ mise plugins link ./mise-node\n"
        flag "-f --force" help="Overwrite existing plugin"
        arg <NAME> help="The name of the plugin\ne.g.: node, ruby"
        arg "[DIR]" help="The local path to the plugin\ne.g.: ./mise-node" required=#false
    }
    cmd ls help="List installed plugins" {
        alias list
        long_help "List installed plugins\n\nCan also show remotely available plugins to install."
        after_long_help "Examples:\n\n    $ mise plugins ls\n    node\n    ruby\n\n    $ mise plugins ls --urls\n    node    https://github.com/asdf-vm/asdf-nodejs.git\n    ruby    https://github.com/asdf-vm/asdf-ruby.git\n"
        flag "-a --all" help="List all available remote plugins\nSame as `mise plugins ls-remote`" hide=#true
        flag "-c --core" help="The built-in plugins only\nNormally these are not shown" hide=#true
        flag --user help="List installed plugins" hide=#true
        flag "-u --urls" help="Show the git url for each plugin\ne.g.: https://github.com/asdf-vm/asdf-nodejs.git"
        flag --refs help="Show the git refs for each plugin\ne.g.: main 1234abc" hide=#true
    }
    cmd ls-remote help="List all available remote plugins" {
        alias list-remote list-all
        long_help "\nList all available remote plugins\n\nThe full list is here: https://github.com/jdx/mise/blob/main/registry.toml\n\nExamples:\n\n    $ mise plugins ls-remote\n"
        flag "-u --urls" help="Show the git url for each plugin e.g.: https://github.com/mise-plugins/mise-poetry.git"
        flag --only-names help="Only show the name of each plugin by default it will show a \"*\" next to installed plugins"
    }
    cmd uninstall help="Removes a plugin" {
        alias remove rm
        after_long_help "Examples:\n\n    $ mise uninstall node\n"
        flag "-p --purge" help="Also remove the plugin's installs, downloads, and cache"
        flag "-a --all" help="Remove all plugins"
        arg "[PLUGIN]..." help="Plugin(s) to remove" required=#false var=#true
    }
    cmd update help="Updates a plugin to the latest version" {
        alias up upgrade
        long_help "Updates a plugin to the latest version\n\nnote: this updates the plugin itself, not the runtime versions"
        after_long_help "Examples:\n\n    $ mise plugins update            # update all plugins\n    $ mise plugins update node       # update only node\n    $ mise plugins update node#beta  # specify a ref\n"
        flag "-j --jobs" help="Number of jobs to run in parallel\nDefault: 4" {
            arg <JOBS>
        }
        arg "[PLUGIN]..." help="Plugin(s) to update" required=#false var=#true
    }
}
cmd prune help="Delete unused versions of tools" {
    long_help "Delete unused versions of tools\n\nmise tracks which config files have been used in ~/.local/state/mise/tracked-configs\nVersions which are no longer the latest specified in any of those configs are deleted.\nVersions installed only with environment variables `MISE_<PLUGIN>_VERSION` will be deleted,\nas will versions only referenced on the command line `mise exec <PLUGIN>@<VERSION>`.\n\nYou can list prunable tools with `mise ls --prunable`"
    after_long_help "Examples:\n\n    $ mise prune --dry-run\n    rm -rf ~/.local/share/mise/versions/node/20.0.0\n    rm -rf ~/.local/share/mise/versions/node/20.0.1\n"
    flag "-n --dry-run" help="Do not actually delete anything"
    flag --configs help="Prune only tracked and trusted configuration links that point to non-existent configurations"
    flag --tools help="Prune only unused versions of tools"
    arg "[INSTALLED_TOOL]..." help="Prune only these tools" required=#false var=#true
}
cmd registry help="List available tools to install" {
    long_help "List available tools to install\n\nThis command lists the tools available in the registry as shorthand names.\n\nFor example, `poetry` is shorthand for `asdf:mise-plugins/mise-poetry`."
    after_long_help "Examples:\n\n    $ mise registry\n    node    core:node\n    poetry  asdf:mise-plugins/mise-poetry\n    ubi     cargo:ubi-cli\n\n    $ mise registry poetry\n    asdf:mise-plugins/mise-poetry\n"
    flag "-b --backend" help="Show only tools for this backend" {
        arg <BACKEND>
    }
    flag --complete help="Print all tools with descriptions for shell completions" hide=#true
    flag --hide-aliased help="Hide aliased tools"
    arg "[NAME]" help="Show only the specified tool's full name" required=#false
}
cmd reshim help="Creates new shims based on bin paths from currently installed tools." {
    long_help "Creates new shims based on bin paths from currently installed tools.\n\nThis creates new shims in ~/.local/share/mise/shims for CLIs that have been added.\nmise will try to do this automatically for commands like `npm i -g` but there are\nother ways to install things (like using yarn or pnpm for node) that mise does\nnot know about and so it will be necessary to call this explicitly.\n\nIf you think mise should automatically call this for a particular command, please\nopen an issue on the mise repo. You can also setup a shell function to reshim\nautomatically (it's really fast so you don't need to worry about overhead):\n\n    npm() {\n      command npm \"$@\"\n      mise reshim\n    }\n\nNote that this creates shims for _all_ installed tools, not just the ones that are\ncurrently active in mise.toml."
    after_long_help "Examples:\n\n    $ mise reshim\n    $ ~/.local/share/mise/shims/node -v\n    v20.0.0\n"
    flag "-f --force" help="Removes all shims before reshimming"
    arg "[PLUGIN]" required=#false hide=#true
    arg "[VERSION]" required=#false hide=#true
}
cmd run help="Run task(s)" {
    alias r
    long_help "Run task(s)\n\nThis command will run a tasks, or multiple tasks in parallel.\nTasks may have dependencies on other tasks or on source files.\nIf source is configured on a tasks, it will only run if the source\nfiles have changed.\n\nTasks can be defined in mise.toml or as standalone scripts.\nIn mise.toml, tasks take this form:\n\n    [tasks.build]\n    run = \"npm run build\"\n    sources = [\"src/**/*.ts\"]\n    outputs = [\"dist/**/*.js\"]\n\nAlternatively, tasks can be defined as standalone scripts.\nThese must be located in `mise-tasks`, `.mise-tasks`, `.mise/tasks`, `mise/tasks` or\n`.config/mise/tasks`.\nThe name of the script will be the name of the tasks.\n\n    $ cat .mise/tasks/build<<EOF\n    #!/usr/bin/env bash\n    npm run build\n    EOF\n    $ mise run build"
    after_long_help "Examples:\n\n    # Runs the \"lint\" tasks. This needs to either be defined in mise.toml\n    # or as a standalone script. See the project README for more information.\n    $ mise run lint\n\n    # Forces the \"build\" tasks to run even if its sources are up-to-date.\n    $ mise run build --force\n\n    # Run \"test\" with stdin/stdout/stderr all connected to the current terminal.\n    # This forces `--jobs=1` to prevent interleaving of output.\n    $ mise run test --raw\n\n    # Runs the \"lint\", \"test\", and \"check\" tasks in parallel.\n    $ mise run lint ::: test ::: check\n\n    # Execute multiple tasks each with their own arguments.\n    $ mise tasks cmd1 arg1 arg2 ::: cmd2 arg1 arg2\n"
    flag "-C --cd" help="Change to this directory before executing the command" {
        arg <CD>
    }
    flag "-c --continue-on-error" help="Continue running tasks even if one fails"
    flag "-n --dry-run" help="Don't actually run the tasks(s), just print them in order of execution"
    flag "-f --force" help="Force the tasks to run even if outputs are up to date"
    flag "-p --prefix" help="Print stdout/stderr by line, prefixed with the task's label\nDefaults to true if --jobs > 1\nConfigure with `task_output` config or `MISE_TASK_OUTPUT` env var" hide=#true
    flag "-i --interleave" help="Print directly to stdout/stderr instead of by line\nDefaults to true if --jobs == 1\nConfigure with `task_output` config or `MISE_TASK_OUTPUT` env var" hide=#true
    flag "-s --shell" help="Shell to use to run toml tasks" {
        long_help "Shell to use to run toml tasks\n\nDefaults to `sh -c -o errexit -o pipefail` on unix, and `cmd /c` on Windows\nCan also be set with the setting `MISE_UNIX_DEFAULT_INLINE_SHELL_ARGS` or `MISE_WINDOWS_DEFAULT_INLINE_SHELL_ARGS`\nOr it can be overridden with the `shell` property on a task."
        arg <SHELL>
    }
    flag "-t --tool" help="Tool(s) to run in addition to what is in mise.toml files e.g.: node@20 python@3.10" var=#true {
        arg <TOOL@VERSION>
    }
    flag "-j --jobs" help="Number of tasks to run in parallel\n[default: 4]\nConfigure with `jobs` config or `MISE_JOBS` env var" {
        arg <JOBS>
    }
    flag "-r --raw" help="Read/write directly to stdin/stdout/stderr instead of by line\nConfigure with `raw` config or `MISE_RAW` env var"
    flag --timings help="Shows elapsed time after each task completes" hide=#true {
        long_help "Shows elapsed time after each task completes\n\nDefault to always show with `MISE_TASK_TIMINGS=1`"
    }
    flag --no-timings help="Hides elapsed time after each task completes" {
        long_help "Hides elapsed time after each task completes\n\nDefault to always hide with `MISE_TASK_TIMINGS=0`"
    }
    flag "-q --quiet" help="Don't show extra output"
    flag "-S --silent" help="Don't show any output except for errors"
    flag "-o --output" help="Change how tasks information is output when running tasks" {
        long_help "Change how tasks information is output when running tasks\n\n- `prefix` - Print stdout/stderr by line, prefixed with the task's label\n- `interleave` - Print directly to stdout/stderr instead of by line\n- `replacing` - Stdout is replaced each time, stderr is printed as is\n- `timed` - Only show stdout lines if they are displayed for more than 1 second\n- `keep-order` - Print stdout/stderr by line, prefixed with the task's label, but keep the order of the output\n- `quiet` - Don't show extra output\n- `silent` - Don't show any output including stdout and stderr from the task except for errors"
        arg <OUTPUT>
    }
    flag --no-cache
    mount run="mise tasks --usage"
}
cmd self-update help="Updates mise itself." {
    long_help "Updates mise itself.\n\nUses the GitHub Releases API to find the latest release and binary.\nBy default, this will also update any installed plugins.\nUses the `GITHUB_API_TOKEN` environment variable if set for higher rate limits.\n\nThis command is not available if mise is installed via a package manager."
    flag "-f --force" help="Update even if already up to date"
    flag --no-plugins help="Disable auto-updating plugins"
    flag "-y --yes" help="Skip confirmation prompt"
    arg "[VERSION]" help="Update to a specific version" required=#false
}
cmd set help="Set environment variables in mise.toml" {
    alias ev env-vars hide=#true
    long_help "Set environment variables in mise.toml\n\nBy default, this command modifies `mise.toml` in the current directory."
    after_long_help "Examples:\n\n    $ mise set NODE_ENV=production\n\n    $ mise set NODE_ENV\n    production\n\n    $ mise set\n    key       value       source\n    NODE_ENV  production  ~/.config/mise/config.toml\n"
    flag --file help="The TOML file to update" {
        long_help "The TOML file to update\n\nDefaults to MISE_DEFAULT_CONFIG_FILENAME environment variable, or `mise.toml`."
        arg <FILE>
    }
    flag --complete help="Render completions" hide=#true
    flag "-g --global" help="Set the environment variable in the global config file"
    flag "--remove --rm --unset" help="Remove the environment variable from config file" var=#true hide=#true {
        long_help "Remove the environment variable from config file\n\nCan be used multiple times."
        arg <ENV_KEY>
    }
    arg "[ENV_VAR]..." help="Environment variable(s) to set\ne.g.: NODE_ENV=production" required=#false var=#true
}
cmd settings help="Manage settings" {
    long_help "Show current settings\n\nThis is the contents of ~/.config/mise/config.toml\n\nNote that aliases are also stored in this file\nbut managed separately with `mise aliases`"
    after_long_help "Examples:\n    # list all settings\n    $ mise settings\n\n    # get the value of the setting \"always_keep_download\"\n    $ mise settings always_keep_download\n\n    # set the value of the setting \"always_keep_download\" to \"true\"\n    $ mise settings always_keep_download=true\n\n    # set the value of the setting \"node.mirror_url\" to \"https://npm.taobao.org/mirrors/node\"\n    $ mise settings node.mirror_url https://npm.taobao.org/mirrors/node\n"
    flag "-a --all" help="List all settings"
    flag --complete help="Print all settings with descriptions for shell completions" hide=#true
    flag "-l --local" help="Use the local config file instead of the global one" global=#true
    flag "-J --json" help="Output in JSON format"
    flag --json-extended help="Output in JSON format with sources"
    flag "-T --toml" help="Output in TOML format"
    arg "[SETTING]" help="Name of setting" required=#false
    arg "[VALUE]" help="Setting value to set" required=#false
    cmd add help="Adds a setting to the configuration file" {
        long_help "Adds a setting to the configuration file\n\nUsed with an array setting, this will append the value to the array.\nThis modifies the contents of ~/.config/mise/config.toml"
        after_long_help "Examples:\n\n    $ mise settings add disable_hints python_multi\n"
        flag "-l --local" help="Use the local config file instead of the global one"
        arg <SETTING> help="The setting to set"
        arg <VALUE> help="The value to set"
    }
    cmd get help="Show a current setting" {
        long_help "Show a current setting\n\nThis is the contents of a single entry in ~/.config/mise/config.toml\n\nNote that aliases are also stored in this file\nbut managed separately with `mise aliases get`"
        after_long_help "Examples:\n\n    $ mise settings get idiomatic_version_file\n    true\n"
        flag "-l --local" help="Use the local config file instead of the global one"
        arg <SETTING> help="The setting to show"
    }
    cmd ls help="Show current settings" {
        alias list
        long_help "Show current settings\n\nThis is the contents of ~/.config/mise/config.toml\n\nNote that aliases are also stored in this file\nbut managed separately with `mise aliases`"
        after_long_help "Examples:\n\n    $ mise settings ls\n    idiomatic_version_file = false\n    ...\n\n    $ mise settings ls python\n    default_packages_file = \"~/.default-python-packages\"\n    ...\n"
        flag "-a --all" help="List all settings"
        flag --complete help="Print all settings with descriptions for shell completions" hide=#true
        flag "-l --local" help="Use the local config file instead of the global one" global=#true
        flag "-J --json" help="Output in JSON format"
        flag --json-extended help="Output in JSON format with sources"
        flag "-T --toml" help="Output in TOML format"
        arg "[SETTING]" help="Name of setting" required=#false
    }
    cmd set help="Add/update a setting" {
        alias create
        long_help "Add/update a setting\n\nThis modifies the contents of ~/.config/mise/config.toml"
        after_long_help "Examples:\n\n    $ mise settings idiomatic_version_file=true\n"
        flag "-l --local" help="Use the local config file instead of the global one"
        arg <SETTING> help="The setting to set"
        arg <VALUE> help="The value to set"
    }
    cmd unset help="Clears a setting" {
        alias rm remove delete del
        long_help "Clears a setting\n\nThis modifies the contents of ~/.config/mise/config.toml"
        after_long_help "Examples:\n\n    $ mise settings unset idiomatic_version_file\n"
        flag "-l --local" help="Use the local config file instead of the global one"
        arg <KEY> help="The setting to remove"
    }
}
cmd shell help="Sets a tool version for the current session." {
    alias sh
    long_help "Sets a tool version for the current session.\n\nOnly works in a session where mise is already activated.\n\nThis works by setting environment variables for the current shell session\nsuch as `MISE_NODE_VERSION=20` which is \"eval\"ed as a shell function created by `mise activate`."
    after_long_help "Examples:\n\n    $ mise shell node@20\n    $ node -v\n    v20.0.0\n"
    flag "-j --jobs" help="Number of jobs to run in parallel\n[default: 4]" {
        arg <JOBS>
    }
    flag --raw help="Directly pipe stdin/stdout/stderr from plugin to user Sets --jobs=1"
    flag "-u --unset" help="Removes a previously set version"
    arg <TOOL@VERSION>... help="Tool(s) to use" var=#true
}
cmd sync subcommand_required=#true help="Synchronize tools from other version managers with mise" {
    cmd node help="Symlinks all tool versions from an external tool into mise" {
        long_help "Symlinks all tool versions from an external tool into mise\n\nFor example, use this to import all Homebrew node installs into mise\n\nThis won't overwrite any existing installs but will overwrite any existing symlinks"
        after_long_help "Examples:\n\n    $ brew install node@18 node@20\n    $ mise sync node --brew\n    $ mise use -g node@18 - uses Homebrew-provided node\n"
        flag --brew help="Get tool versions from Homebrew"
        flag --nvm help="Get tool versions from nvm"
        flag --nodenv help="Get tool versions from nodenv"
    }
    cmd python help="Symlinks all tool versions from an external tool into mise" {
        long_help "Symlinks all tool versions from an external tool into mise\n\nFor example, use this to import all pyenv installs into mise\n\nThis won't overwrite any existing installs but will overwrite any existing symlinks"
        after_long_help "Examples:\n\n    $ pyenv install 3.11.0\n    $ mise sync python --pyenv\n    $ mise use -g python@3.11.0 - uses pyenv-provided python\n    \n    $ uv python install 3.11.0\n    $ mise install python@3.10.0\n    $ mise sync python --uv\n    $ mise x python@3.11.0 -- python -V - uses uv-provided python\n    $ uv run -p 3.10.0 -- python -V - uses mise-provided python\n"
        flag --pyenv help="Get tool versions from pyenv"
        flag --uv help="Sync tool versions with uv (2-way sync)"
    }
    cmd ruby help="Symlinks all ruby tool versions from an external tool into mise" {
        after_long_help "Examples:\n\n    $ brew install ruby\n    $ mise sync ruby --brew\n    $ mise use -g ruby - Use the latest version of Ruby installed by Homebrew\n"
        flag --brew help="Get tool versions from Homebrew"
    }
}
cmd tasks help="Manage tasks" {
    alias t
    alias task hide=#true
    after_long_help "Examples:\n\n    $ mise tasks ls\n"
    flag --no-header help="Do not print table header" global=#true
    flag --complete help="Display tasks for usage completion" hide=#true
    flag "-x --extended" help="Show all columns" global=#true
    flag --hidden help="Show hidden tasks" global=#true
    flag --sort help="Sort by column. Default is name." global=#true {
        arg <COLUMN> {
            choices name alias description source
        }
    }
    flag --sort-order help="Sort order. Default is asc." global=#true {
        arg <SORT_ORDER> {
            choices asc desc
        }
    }
    flag "-J --json" help="Output in JSON format" global=#true
    flag --usage hide=#true global=#true
    arg "[TASK]" help="Task name to get info of" required=#false
    cmd add help="Create a new task" {
        after_long_help "Examples:\n\n    $ mise task add pre-commit --depends \"test\" --depends \"render\" -- echo pre-commit\n"
        flag --description help="Description of the task" {
            arg <DESCRIPTION>
        }
        flag "-a --alias" help="Other names for the task" var=#true {
            arg <ALIAS>
        }
        flag --depends-post help="Dependencies to run after the task runs" var=#true {
            arg <DEPENDS_POST>
        }
        flag "-w --wait-for" help="Wait for these tasks to complete if they are to run" var=#true {
            arg <WAIT_FOR>
        }
        flag "-D --dir" help="Run the task in a specific directory" {
            arg <DIR>
        }
        flag "-H --hide" help="Hide the task from `mise task` and completions"
        flag "-r --raw" help="Directly connect stdin/stdout/stderr"
        flag "-s --sources" help="Glob patterns of files this task uses as input" var=#true {
            arg <SOURCES>
        }
        flag --outputs help="Glob patterns of files this task creates, to skip if they are not modified" var=#true {
            arg <OUTPUTS>
        }
        flag --shell help="Run the task in a specific shell" {
            arg <SHELL>
        }
        flag "-q --quiet" help="Do not print the command before running"
        flag --silent help="Do not print the command or its output"
        flag "-d --depends" help="Add dependencies to the task" var=#true {
            arg <DEPENDS>
        }
        flag --run-windows help="Command to run on windows" {
            arg <RUN_WINDOWS>
        }
        flag "-f --file" help="Create a file task instead of a toml task"
        arg <TASK> help="Tasks name to add"
        arg "[-- RUN]..." required=#false var=#true
    }
    cmd deps help="Display a tree visualization of a dependency graph" {
        after_long_help "Examples:\n\n    # Show dependencies for all tasks\n    $ mise tasks deps\n\n    # Show dependencies for the \"lint\", \"test\" and \"check\" tasks\n    $ mise tasks deps lint test check\n\n    # Show dependencies in DOT format\n    $ mise tasks deps --dot\n"
        flag --hidden help="Show hidden tasks"
        flag --dot help="Display dependencies in DOT format"
        arg "[TASKS]..." help="Tasks to show dependencies for\nCan specify multiple tasks by separating with spaces\ne.g.: mise tasks deps lint test check" required=#false var=#true
    }
    cmd edit help="Edit a tasks with $EDITOR" {
        long_help "Edit a tasks with $EDITOR\n\nThe tasks will be created as a standalone script if it does not already exist."
        after_long_help "Examples:\n\n    $ mise tasks edit build\n    $ mise tasks edit test\n"
        flag "-p --path" help="Display the path to the tasks instead of editing it"
        arg <TASK> help="Tasks to edit"
    }
    cmd info help="Get information about a task" {
        after_long_help "Examples:\n\n    $ mise tasks info\n    Name: test\n    Aliases: t\n    Description: Test the application\n    Source: ~/src/myproj/mise.toml\n\n    $ mise tasks info test --json\n    {\n      \"name\": \"test\",\n      \"aliases\": \"t\",\n      \"description\": \"Test the application\",\n      \"source\": \"~/src/myproj/mise.toml\",\n      \"depends\": [],\n      \"env\": {},\n      \"dir\": null,\n      \"hide\": false,\n      \"raw\": false,\n      \"sources\": [],\n      \"outputs\": [],\n      \"run\": [\n        \"echo \\\"testing!\\\"\"\n      ],\n      \"file\": null,\n      \"usage_spec\": {}\n    }\n"
        flag "-J --json" help="Output in JSON format"
        arg <TASK> help="Name of the task to get information about"
    }
    cmd ls help="List available tasks to execute\nThese may be included from the config file or from the project's .mise/tasks directory\nmise will merge all tasks from all parent directories into this list." {
        long_help "List available tasks to execute\nThese may be included from the config file or from the project's .mise/tasks directory\nmise will merge all tasks from all parent directories into this list.\n\nSo if you have global tasks in `~/.config/mise/tasks/*` and project-specific tasks in\n~/myproject/.mise/tasks/*, then they'll both be available but the project-specific\ntasks will override the global ones if they have the same name."
        after_long_help "Examples:\n\n    $ mise tasks ls\n"
        flag --no-header help="Do not print table header" global=#true
        flag --complete help="Display tasks for usage completion" hide=#true
        flag "-x --extended" help="Show all columns" global=#true
        flag --hidden help="Show hidden tasks" global=#true
        flag --sort help="Sort by column. Default is name." global=#true {
            arg <COLUMN> {
                choices name alias description source
            }
        }
        flag --sort-order help="Sort order. Default is asc." global=#true {
            arg <SORT_ORDER> {
                choices asc desc
            }
        }
        flag "-J --json" help="Output in JSON format" global=#true
        flag --usage hide=#true global=#true
    }
    cmd run help="Run task(s)" {
        alias r
        long_help "Run task(s)\n\nThis command will run a tasks, or multiple tasks in parallel.\nTasks may have dependencies on other tasks or on source files.\nIf source is configured on a tasks, it will only run if the source\nfiles have changed.\n\nTasks can be defined in mise.toml or as standalone scripts.\nIn mise.toml, tasks take this form:\n\n    [tasks.build]\n    run = \"npm run build\"\n    sources = [\"src/**/*.ts\"]\n    outputs = [\"dist/**/*.js\"]\n\nAlternatively, tasks can be defined as standalone scripts.\nThese must be located in `mise-tasks`, `.mise-tasks`, `.mise/tasks`, `mise/tasks` or\n`.config/mise/tasks`.\nThe name of the script will be the name of the tasks.\n\n    $ cat .mise/tasks/build<<EOF\n    #!/usr/bin/env bash\n    npm run build\n    EOF\n    $ mise run build"
        after_long_help "Examples:\n\n    # Runs the \"lint\" tasks. This needs to either be defined in mise.toml\n    # or as a standalone script. See the project README for more information.\n    $ mise run lint\n\n    # Forces the \"build\" tasks to run even if its sources are up-to-date.\n    $ mise run build --force\n\n    # Run \"test\" with stdin/stdout/stderr all connected to the current terminal.\n    # This forces `--jobs=1` to prevent interleaving of output.\n    $ mise run test --raw\n\n    # Runs the \"lint\", \"test\", and \"check\" tasks in parallel.\n    $ mise run lint ::: test ::: check\n\n    # Execute multiple tasks each with their own arguments.\n    $ mise tasks cmd1 arg1 arg2 ::: cmd2 arg1 arg2\n"
        flag "-C --cd" help="Change to this directory before executing the command" {
            arg <CD>
        }
        flag "-c --continue-on-error" help="Continue running tasks even if one fails"
        flag "-n --dry-run" help="Don't actually run the tasks(s), just print them in order of execution"
        flag "-f --force" help="Force the tasks to run even if outputs are up to date"
        flag "-p --prefix" help="Print stdout/stderr by line, prefixed with the task's label\nDefaults to true if --jobs > 1\nConfigure with `task_output` config or `MISE_TASK_OUTPUT` env var" hide=#true
        flag "-i --interleave" help="Print directly to stdout/stderr instead of by line\nDefaults to true if --jobs == 1\nConfigure with `task_output` config or `MISE_TASK_OUTPUT` env var" hide=#true
        flag "-s --shell" help="Shell to use to run toml tasks" {
            long_help "Shell to use to run toml tasks\n\nDefaults to `sh -c -o errexit -o pipefail` on unix, and `cmd /c` on Windows\nCan also be set with the setting `MISE_UNIX_DEFAULT_INLINE_SHELL_ARGS` or `MISE_WINDOWS_DEFAULT_INLINE_SHELL_ARGS`\nOr it can be overridden with the `shell` property on a task."
            arg <SHELL>
        }
        flag "-t --tool" help="Tool(s) to run in addition to what is in mise.toml files e.g.: node@20 python@3.10" var=#true {
            arg <TOOL@VERSION>
        }
        flag "-j --jobs" help="Number of tasks to run in parallel\n[default: 4]\nConfigure with `jobs` config or `MISE_JOBS` env var" {
            arg <JOBS>
        }
        flag "-r --raw" help="Read/write directly to stdin/stdout/stderr instead of by line\nConfigure with `raw` config or `MISE_RAW` env var"
        flag --timings help="Shows elapsed time after each task completes" hide=#true {
            long_help "Shows elapsed time after each task completes\n\nDefault to always show with `MISE_TASK_TIMINGS=1`"
        }
        flag --no-timings help="Hides elapsed time after each task completes" {
            long_help "Hides elapsed time after each task completes\n\nDefault to always hide with `MISE_TASK_TIMINGS=0`"
        }
        flag "-q --quiet" help="Don't show extra output"
        flag "-S --silent" help="Don't show any output except for errors"
        flag "-o --output" help="Change how tasks information is output when running tasks" {
            long_help "Change how tasks information is output when running tasks\n\n- `prefix` - Print stdout/stderr by line, prefixed with the task's label\n- `interleave` - Print directly to stdout/stderr instead of by line\n- `replacing` - Stdout is replaced each time, stderr is printed as is\n- `timed` - Only show stdout lines if they are displayed for more than 1 second\n- `keep-order` - Print stdout/stderr by line, prefixed with the task's label, but keep the order of the output\n- `quiet` - Don't show extra output\n- `silent` - Don't show any output including stdout and stderr from the task except for errors"
            arg <OUTPUT>
        }
        flag --no-cache
        arg "[TASK]" help="Tasks to run\nCan specify multiple tasks by separating with `:::`\ne.g.: mise run task1 arg1 arg2 ::: task2 arg1 arg2" required=#false default=default
        arg "[ARGS]..." help="Arguments to pass to the tasks. Use \":::\" to separate tasks" required=#false var=#true
        arg "[-- ARGS_LAST]..." help="Arguments to pass to the tasks. Use \":::\" to separate tasks" required=#false var=#true hide=#true
        mount run="mise tasks --usage"
    }
}
cmd test-tool help="Test a tool installs and executes" {
    after_long_help "Examples:\n\n    $ mise test-tool ripgrep\n"
    flag "-a --all" help="Test every tool specified in registry.toml"
    flag --all-config help="Test all tools specified in config files"
    flag --include-non-defined help="Also test tools not defined in registry.toml, guessing how to test it"
    flag "-j --jobs" help="Number of jobs to run in parallel\n[default: 4]" {
        arg <JOBS>
    }
    flag --raw help="Directly pipe stdin/stdout/stderr from plugin to user Sets --jobs=1"
    arg "[TOOL]" help="Tool name to test" required=#false
}
cmd tool help="Gets information about a tool" {
    after_long_help "Examples:\n\n    $ mise tool node\n    Backend:            core\n    Installed Versions: 20.0.0 22.0.0\n    Active Version:     20.0.0\n    Requested Version:  20\n    Config Source:      ~/.config/mise/mise.toml\n    Tool Options:       [none]\n"
    flag "-J --json" help="Output in JSON format"
    flag --backend help="Only show backend field"
    flag --description help="Only show description field"
    flag --installed help="Only show installed versions"
    flag --active help="Only show active versions"
    flag --requested help="Only show requested versions"
    flag --config-source help="Only show config source"
    flag --tool-options help="Only show tool options"
    arg <TOOL> help="Tool name to get information about"
}
cmd trust help="Marks a config file as trusted" {
    long_help "Marks a config file as trusted\n\nThis means mise will parse the file with potentially dangerous\nfeatures enabled.\n\nThis includes:\n- environment variables\n- templates\n- `path:` plugin versions"
    after_long_help "Examples:\n\n    # trusts ~/some_dir/mise.toml\n    $ mise trust ~/some_dir/mise.toml\n\n    # trusts mise.toml in the current or parent directory\n    $ mise trust\n"
    flag "-a --all" help="Trust all config files in the current directory and its parents"
    flag --ignore help="Do not trust this config and ignore it in the future"
    flag --untrust help="No longer trust this config, will prompt in the future"
    flag --show help="Show the trusted status of config files from the current directory and its parents.\nDoes not trust or untrust any files."
    arg "[CONFIG_FILE]" help="The config file to trust" required=#false
}
cmd uninstall help="Removes installed tool versions" {
    long_help "Removes installed tool versions\n\nThis only removes the installed version, it does not modify mise.toml."
    after_long_help "Examples:\n\n    # will uninstall specific version\n    $ mise uninstall node@18.0.0\n\n    # will uninstall the current node version (if only one version is installed)\n    $ mise uninstall node\n\n    # will uninstall all installed versions of node\n    $ mise uninstall --all node@18.0.0 # will uninstall all node versions\n"
    flag "-a --all" help="Delete all installed versions"
    flag "-n --dry-run" help="Do not actually delete anything"
    arg "[INSTALLED_TOOL@VERSION]..." help="Tool(s) to remove" required=#false var=#true
}
cmd unset help="Remove environment variable(s) from the config file." {
    long_help "Remove environment variable(s) from the config file.\n\nBy default, this command modifies `mise.toml` in the current directory."
    after_long_help "Examples:\n\n    # Remove NODE_ENV from the current directory's config\n    $ mise unset NODE_ENV\n\n    # Remove NODE_ENV from the global config\n    $ mise unset NODE_ENV -g\n"
    flag "-f --file" help="Specify a file to use instead of `mise.toml`" {
        arg <FILE>
    }
    flag "-g --global" help="Use the global config file"
    arg "[ENV_KEY]..." help="Environment variable(s) to remove\ne.g.: NODE_ENV" required=#false var=#true
}
cmd unuse help="Removes installed tool versions from mise.toml" {
    alias rm remove
    long_help "Removes installed tool versions from mise.toml\n\nWill also prune the installed version if no other configurations are using it."
    after_long_help "Examples:\n\n    # will uninstall specific version\n    $ mise unuse node@18.0.0\n\n    # will uninstall specific version from global config\n    $ mise unuse -g node@18.0.0\n"
    flag --no-prune help="Do not also prune the installed version"
    flag "-g --global" help="Remove tool from global config"
    arg <INSTALLED_TOOL@VERSION>... help="Tool(s) to remove" var=#true
}
cmd upgrade help="Upgrades outdated tools" {
    alias up
    long_help "Upgrades outdated tools\n\nBy default, this keeps the range specified in mise.toml. So if you have node@20 set, it will\nupgrade to the latest 20.x.x version available. See the `--bump` flag to use the latest version\nand bump the version in mise.toml.\n\nThis will update mise.lock if it is enabled, see https://mise.jdx.dev/configuration/settings.html#lockfile"
    after_long_help "Examples:\n\n    # Upgrades node to the latest version matching the range in mise.toml\n    $ mise upgrade node\n\n    # Upgrades node to the latest version and bumps the version in mise.toml\n    $ mise upgrade node --bump\n\n    # Upgrades all tools to the latest versions\n    $ mise upgrade\n\n    # Upgrades all tools to the latest versions and bumps the version in mise.toml\n    $ mise upgrade --bump\n\n    # Just print what would be done, don't actually do it\n    $ mise upgrade --dry-run\n\n    # Upgrades node and python to the latest versions\n    $ mise upgrade node python\n\n    # Show a multiselect menu to choose which tools to upgrade\n    $ mise upgrade --interactive\n"
    flag "-n --dry-run" help="Just print what would be done, don't actually do it"
    flag "-i --interactive" help="Display multiselect menu to choose which tools to upgrade"
    flag "-j --jobs" help="Number of jobs to run in parallel\n[default: 4]" {
        arg <JOBS>
    }
    flag "-l --bump" help="Upgrades to the latest version available, bumping the version in mise.toml" {
        long_help "Upgrades to the latest version available, bumping the version in mise.toml\n\nFor example, if you have `node = \"20.0.0\"` in your mise.toml but 22.1.0 is the latest available,\nthis will install 22.1.0 and set `node = \"22.1.0\"` in your config.\n\nIt keeps the same precision as what was there before, so if you instead had `node = \"20\"`, it\nwould change your config to `node = \"22\"`."
    }
    flag --raw help="Directly pipe stdin/stdout/stderr from plugin to user Sets --jobs=1"
    arg "[TOOL@VERSION]..." help="Tool(s) to upgrade\ne.g.: node@20 python@3.10\nIf not specified, all current tools will be upgraded" required=#false var=#true
}
cmd usage hide=#true help="Generate a usage CLI spec" {
    long_help "Generate a usage CLI spec\n\nSee https://usage.jdx.dev for more information on this specification."
}
cmd use help="Installs a tool and adds the version to mise.toml." {
    alias u
    long_help "Installs a tool and adds the version to mise.toml.\n\nThis will install the tool version if it is not already installed.\nBy default, this will use a `mise.toml` file in the current directory.\n\nIn the following order:\n  - If `MISE_DEFAULT_CONFIG_FILENAME` is set, it will use that instead.\n  - If `MISE_OVERRIDE_CONFIG_FILENAMES` is set, it will the first from that list.\n  - If `MISE_ENV` is set, it will use a `mise.<env>.toml` instead.\n  - Otherwise just \"mise.toml\"\n\nUse the `--global` flag to use the global config file instead."
    after_long_help "Examples:\n    \n    # run with no arguments to use the interactive selector\n    $ mise use\n\n    # set the current version of node to 20.x in mise.toml of current directory\n    # will write the fuzzy version (e.g.: 20)\n    $ mise use node@20\n\n    # set the current version of node to 20.x in ~/.config/mise/config.toml\n    # will write the precise version (e.g.: 20.0.0)\n    $ mise use -g --pin node@20\n\n    # sets .mise.local.toml (which is intended not to be committed to a project)\n    $ mise use --env local node@20\n\n    # sets .mise.staging.toml (which is used if MISE_ENV=staging)\n    $ mise use --env staging node@20\n"
    flag "-f --force" help="Force reinstall even if already installed"
    flag --fuzzy help="Save fuzzy version to config file" {
        long_help "Save fuzzy version to config file\n\ne.g.: `mise use --fuzzy node@20` will save 20 as the version\nthis is the default behavior unless `MISE_PIN=1`"
    }
    flag "-g --global" help="Use the global config file (`~/.config/mise/config.toml`) instead of the local one"
    flag "-e --env" help="Create/modify an environment-specific config file like .mise.<env>.toml" {
        arg <ENV>
    }
    flag "-j --jobs" help="Number of jobs to run in parallel\n[default: 4]" {
        arg <JOBS>
    }
    flag --raw help="Directly pipe stdin/stdout/stderr from plugin to user Sets `--jobs=1`"
    flag --remove help="Remove the plugin(s) from config file" var=#true {
        arg <PLUGIN>
    }
    flag "-p --path" help="Specify a path to a config file or directory" {
        long_help "Specify a path to a config file or directory\n\nIf a directory is specified, it will look for a config file in that directory following the rules above."
        arg <PATH>
    }
    flag --pin help="Save exact version to config file\ne.g.: `mise use --pin node@20` will save 20.0.0 as the version\nSet `MISE_PIN=1` to make this the default behavior" {
        long_help "Save exact version to config file\ne.g.: `mise use --pin node@20` will save 20.0.0 as the version\nSet `MISE_PIN=1` to make this the default behavior\n\nConsider using mise.lock as a better alternative to pinning in mise.toml:\nhttps://mise.jdx.dev/configuration/settings.html#lockfile"
    }
    arg "[TOOL@VERSION]..." help="Tool(s) to add to config file" help_long="Tool(s) to add to config file\n\ne.g.: node@20, cargo:ripgrep@latest npm:prettier@3\nIf no version is specified, it will default to @latest\n\nTool options can be set with this syntax:\n\n    mise use ubi:BurntSushi/ripgrep[exe=rg]" required=#false var=#true
}
cmd version help="Display the version of mise" {
    alias v
    long_help "Display the version of mise\n\nDisplays the version, os, architecture, and the date of the build.\n\nIf the version is out of date, it will display a warning."
    after_long_help "Examples:\n\n    $ mise version\n    $ mise --version\n    $ mise -v\n    $ mise -V\n"
    flag "-J --json" help="Print the version information in JSON format"
}
cmd watch help="Run task(s) and watch for changes to rerun it" {
    alias w
    long_help "Run task(s) and watch for changes to rerun it\n\nThis command uses the `watchexec` tool to watch for changes to files and rerun the specified task(s).\nIt must be installed for this command to work, but you can install it with `mise use -g watchexec@latest`."
    after_long_help "Examples:\n\n    $ mise watch build\n    Runs the \"build\" tasks. Will re-run the tasks when any of its sources change.\n    Uses \"sources\" from the tasks definition to determine which files to watch.\n\n    $ mise watch build --glob src/**/*.rs\n    Runs the \"build\" tasks but specify the files to watch with a glob pattern.\n    This overrides the \"sources\" from the tasks definition.\n\n    $ mise watch build --clear\n    Extra arguments are passed to watchexec. See `watchexec --help` for details.\n\n    $ mise watch serve --watch src --exts rs --restart\n    Starts an api server, watching for changes to \"*.rs\" files in \"./src\" and kills/restarts the server when they change.\n"
    flag "-t --task-flag" help="Tasks to run" var=#true hide=#true {
        arg <TASK_FLAG>
    }
    flag "-g --glob" help="Files to watch\nDefaults to sources from the tasks(s)" var=#true hide=#true {
        arg <GLOB>
    }
    flag "-w --watch" help="Watch a specific file or directory" var=#true {
        long_help "Watch a specific file or directory\n\nBy default, Watchexec watches the current directory.\n\nWhen watching a single file, it's often better to watch the containing directory instead, and filter on the filename. Some editors may replace the file with a new one when saving, and some platforms may not detect that or further changes.\n\nUpon starting, Watchexec resolves a \"project origin\" from the watched paths. See the help for '--project-origin' for more information.\n\nThis option can be specified multiple times to watch multiple files or directories.\n\nThe special value '/dev/null', provided as the only path watched, will cause Watchexec to not watch any paths. Other event sources (like signals or key events) may still be used."
        arg <PATH>
    }
    flag "-W --watch-non-recursive" help="Watch a specific directory, non-recursively" var=#true {
        long_help "Watch a specific directory, non-recursively\n\nUnlike '-w', folders watched with this option are not recursed into.\n\nThis option can be specified multiple times to watch multiple directories non-recursively."
        arg <PATH>
    }
    flag "-F --watch-file" help="Watch files and directories from a file" {
        long_help "Watch files and directories from a file\n\nEach line in the file will be interpreted as if given to '-w'.\n\nFor more complex uses (like watching non-recursively), use the argfile capability: build a file containing command-line options and pass it to watchexec with `@path/to/argfile`.\n\nThe special value '-' will read from STDIN; this in incompatible with '--stdin-quit'."
        arg <PATH>
    }
    flag "-c --clear" help="Clear screen before running command" {
        long_help "Clear screen before running command\n\nIf this doesn't completely clear the screen, try '--clear=reset'."
        arg <MODE> {
            choices clear reset
        }
    }
    flag "-o --on-busy-update" help="What to do when receiving events while the command is running" {
        long_help "What to do when receiving events while the command is running\n\nDefault is to 'do-nothing', which ignores events while the command is running, so that changes that occur due to the command are ignored, like compilation outputs. You can also use 'queue' which will run the command once again when the current run has finished if any events occur while it's running, or 'restart', which terminates the running command and starts a new one. Finally, there's 'signal', which only sends a signal; this can be useful with programs that can reload their configuration without a full restart.\n\nThe signal can be specified with the '--signal' option."
        arg <MODE> {
            choices queue do-nothing restart signal
        }
    }
    flag "-r --restart" help="Restart the process if it's still running" {
        long_help "Restart the process if it's still running\n\nThis is a shorthand for '--on-busy-update=restart'."
    }
    flag "-s --signal" help="Send a signal to the process when it's still running" {
        long_help "Send a signal to the process when it's still running\n\nSpecify a signal to send to the process when it's still running. This implies '--on-busy-update=signal'; otherwise the signal used when that mode is 'restart' is controlled by '--stop-signal'.\n\nSee the long documentation for '--stop-signal' for syntax.\n\nSignals are not supported on Windows at the moment, and will always be overridden to 'kill'. See '--stop-signal' for more on Windows \"signals\"."
        arg <SIGNAL>
    }
    flag --stop-signal help="Signal to send to stop the command" {
        long_help "Signal to send to stop the command\n\nThis is used by 'restart' and 'signal' modes of '--on-busy-update' (unless '--signal' is provided). The restart behaviour is to send the signal, wait for the command to exit, and if it hasn't exited after some time (see '--timeout-stop'), forcefully terminate it.\n\nThe default on unix is \"SIGTERM\".\n\nInput is parsed as a full signal name (like \"SIGTERM\"), a short signal name (like \"TERM\"), or a signal number (like \"15\"). All input is case-insensitive.\n\nOn Windows this option is technically supported but only supports the \"KILL\" event, as Watchexec cannot yet deliver other events. Windows doesn't have signals as such; instead it has termination (here called \"KILL\" or \"STOP\") and \"CTRL+C\", \"CTRL+BREAK\", and \"CTRL+CLOSE\" events. For portability the unix signals \"SIGKILL\", \"SIGINT\", \"SIGTERM\", and \"SIGHUP\" are respectively mapped to these."
        arg <SIGNAL>
    }
    flag --stop-timeout help="Time to wait for the command to exit gracefully" {
        long_help "Time to wait for the command to exit gracefully\n\nThis is used by the 'restart' mode of '--on-busy-update'. After the graceful stop signal is sent, Watchexec will wait for the command to exit. If it hasn't exited after this time, it is forcefully terminated.\n\nTakes a unit-less value in seconds, or a time span value such as \"5min 20s\". Providing a unit-less value is deprecated and will warn; it will be an error in the future.\n\nThe default is 10 seconds. Set to 0 to immediately force-kill the command.\n\nThis has no practical effect on Windows as the command is always forcefully terminated; see '--stop-signal' for why."
        arg <TIMEOUT>
    }
    flag --map-signal help="Translate signals from the OS to signals to send to the command" var=#true {
        long_help "Translate signals from the OS to signals to send to the command\n\nTakes a pair of signal names, separated by a colon, such as \"TERM:INT\" to map SIGTERM to SIGINT. The first signal is the one received by watchexec, and the second is the one sent to the command. The second can be omitted to discard the first signal, such as \"TERM:\" to not do anything on SIGTERM.\n\nIf SIGINT or SIGTERM are mapped, then they no longer quit Watchexec. Besides making it hard to quit Watchexec itself, this is useful to send pass a Ctrl-C to the command without also terminating Watchexec and the underlying program with it, e.g. with \"INT:INT\".\n\nThis option can be specified multiple times to map multiple signals.\n\nSignal syntax is case-insensitive for short names (like \"TERM\", \"USR2\") and long names (like \"SIGKILL\", \"SIGHUP\"). Signal numbers are also supported (like \"15\", \"31\"). On Windows, the forms \"STOP\", \"CTRL+C\", and \"CTRL+BREAK\" are also supported to receive, but Watchexec cannot yet deliver other \"signals\" than a STOP."
        arg <SIGNAL:SIGNAL>
    }
    flag "-d --debounce" help="Time to wait for new events before taking action" {
        long_help "Time to wait for new events before taking action\n\nWhen an event is received, Watchexec will wait for up to this amount of time before handling it (such as running the command). This is essential as what you might perceive as a single change may actually emit many events, and without this behaviour, Watchexec would run much too often. Additionally, it's not infrequent that file writes are not atomic, and each write may emit an event, so this is a good way to avoid running a command while a file is partially written.\n\nAn alternative use is to set a high value (like \"30min\" or longer), to save power or bandwidth on intensive tasks, like an ad-hoc backup script. In those use cases, note that every accumulated event will build up in memory.\n\nTakes a unit-less value in milliseconds, or a time span value such as \"5sec 20ms\". Providing a unit-less value is deprecated and will warn; it will be an error in the future.\n\nThe default is 50 milliseconds. Setting to 0 is highly discouraged."
        arg <TIMEOUT>
    }
    flag --stdin-quit help="Exit when stdin closes" {
        long_help "Exit when stdin closes\n\nThis watches the stdin file descriptor for EOF, and exits Watchexec gracefully when it is closed. This is used by some process managers to avoid leaving zombie processes around."
    }
    flag --no-vcs-ignore help="Don't load gitignores" {
        long_help "Don't load gitignores\n\nAmong other VCS exclude files, like for Mercurial, Subversion, Bazaar, DARCS, Fossil. Note that Watchexec will detect which of these is in use, if any, and only load the relevant files. Both global (like '~/.gitignore') and local (like '.gitignore') files are considered.\n\nThis option is useful if you want to watch files that are ignored by Git."
    }
    flag --no-project-ignore help="Don't load project-local ignores" {
        long_help "Don't load project-local ignores\n\nThis disables loading of project-local ignore files, like '.gitignore' or '.ignore' in the\nwatched project. This is contrasted with '--no-vcs-ignore', which disables loading of Git\nand other VCS ignore files, and with '--no-global-ignore', which disables loading of global\nor user ignore files, like '~/.gitignore' or '~/.config/watchexec/ignore'.\n\nSupported project ignore files:\n\n  - Git: .gitignore at project root and child directories, .git/info/exclude, and the file pointed to by `core.excludesFile` in .git/config.\n  - Mercurial: .hgignore at project root and child directories.\n  - Bazaar: .bzrignore at project root.\n  - Darcs: _darcs/prefs/boring\n  - Fossil: .fossil-settings/ignore-glob\n  - Ripgrep/Watchexec/generic: .ignore at project root and child directories.\n\nVCS ignore files (Git, Mercurial, Bazaar, Darcs, Fossil) are only used if the corresponding\nVCS is discovered to be in use for the project/origin. For example, a .bzrignore in a Git\nrepository will be discarded."
    }
    flag --no-global-ignore help="Don't load global ignores" {
        long_help "Don't load global ignores\n\nThis disables loading of global or user ignore files, like '~/.gitignore',\n'~/.config/watchexec/ignore', or '%APPDATA%\\Bazzar\\2.0\\ignore'. Contrast with\n'--no-vcs-ignore' and '--no-project-ignore'.\n\nSupported global ignore files\n\n  - Git (if core.excludesFile is set): the file at that path\n  - Git (otherwise): the first found of $XDG_CONFIG_HOME/git/ignore, %APPDATA%/.gitignore, %USERPROFILE%/.gitignore, $HOME/.config/git/ignore, $HOME/.gitignore.\n  - Bazaar: the first found of %APPDATA%/Bazzar/2.0/ignore, $HOME/.bazaar/ignore.\n  - Watchexec: the first found of $XDG_CONFIG_HOME/watchexec/ignore, %APPDATA%/watchexec/ignore, %USERPROFILE%/.watchexec/ignore, $HOME/.watchexec/ignore.\n\nLike for project files, Git and Bazaar global files will only be used for the corresponding\nVCS as used in the project."
    }
    flag --no-default-ignore help="Don't use internal default ignores" {
        long_help "Don't use internal default ignores\n\nWatchexec has a set of default ignore patterns, such as editor swap files, `*.pyc`, `*.pyo`, `.DS_Store`, `.bzr`, `_darcs`, `.fossil-settings`, `.git`, `.hg`, `.pijul`, `.svn`, and Watchexec log files."
    }
    flag --no-discover-ignore help="Don't discover ignore files at all" {
        long_help "Don't discover ignore files at all\n\nThis is a shorthand for '--no-global-ignore', '--no-vcs-ignore', '--no-project-ignore', but even more efficient as it will skip all the ignore discovery mechanisms from the get go.\n\nNote that default ignores are still loaded, see '--no-default-ignore'."
    }
    flag --ignore-nothing help="Don't ignore anything at all" {
        long_help "Don't ignore anything at all\n\nThis is a shorthand for '--no-discover-ignore', '--no-default-ignore'.\n\nNote that ignores explicitly loaded via other command line options, such as '--ignore' or '--ignore-file', will still be used."
    }
    flag "-p --postpone" help="Wait until first change before running command" {
        long_help "Wait until first change before running command\n\nBy default, Watchexec will run the command once immediately. With this option, it will instead wait until an event is detected before running the command as normal."
    }
    flag --delay-run help="Sleep before running the command" {
        long_help "Sleep before running the command\n\nThis option will cause Watchexec to sleep for the specified amount of time before running the command, after an event is detected. This is like using \"sleep 5 && command\" in a shell, but portable and slightly more efficient.\n\nTakes a unit-less value in seconds, or a time span value such as \"2min 5s\". Providing a unit-less value is deprecated and will warn; it will be an error in the future."
        arg <DURATION>
    }
    flag --poll help="Poll for filesystem changes" {
        long_help "Poll for filesystem changes\n\nBy default, and where available, Watchexec uses the operating system's native file system watching capabilities. This option disables that and instead uses a polling mechanism, which is less efficient but can work around issues with some file systems (like network shares) or edge cases.\n\nOptionally takes a unit-less value in milliseconds, or a time span value such as \"2s 500ms\", to use as the polling interval. If not specified, the default is 30 seconds. Providing a unit-less value is deprecated and will warn; it will be an error in the future.\n\nAliased as '--force-poll'."
        arg <INTERVAL>
    }
    flag --shell help="Use a different shell" {
        long_help "Use a different shell\n\nBy default, Watchexec will use '$SHELL' if it's defined or a default of 'sh' on Unix-likes, and either 'pwsh', 'powershell', or 'cmd' (CMD.EXE) on Windows, depending on what Watchexec detects is the running shell.\n\nWith this option, you can override that and use a different shell, for example one with more features or one which has your custom aliases and functions.\n\nIf the value has spaces, it is parsed as a command line, and the first word used as the shell program, with the rest as arguments to the shell.\n\nThe command is run with the '-c' flag (except for 'cmd' on Windows, where it's '/C').\n\nThe special value 'none' can be used to disable shell use entirely. In that case, the command provided to Watchexec will be parsed, with the first word being the executable and the rest being the arguments, and executed directly. Note that this parsing is rudimentary, and may not work as expected in all cases.\n\nUsing 'none' is a little more efficient and can enable a stricter interpretation of the input, but it also means that you can't use shell features like globbing, redirection, control flow, logic, or pipes.\n\nExamples:\n\nUse without shell:\n\n$ watchexec -n -- zsh -x -o shwordsplit scr\n\nUse with powershell core:\n\n$ watchexec --shell=pwsh -- Test-Connection localhost\n\nUse with CMD.exe:\n\n$ watchexec --shell=cmd -- dir\n\nUse with a different unix shell:\n\n$ watchexec --shell=bash -- 'echo $BASH_VERSION'\n\nUse with a unix shell and options:\n\n$ watchexec --shell='zsh -x -o shwordsplit' -- scr"
        arg <SHELL>
    }
    flag -n help="Shorthand for '--shell=none'"
    flag --emit-events-to help="Configure event emission" {
        long_help "Configure event emission\n\nWatchexec can emit event information when running a command, which can be used by the child\nprocess to target specific changed files.\n\nOne thing to take care with is assuming inherent behaviour where there is only chance.\nNotably, it could appear as if the `RENAMED` variable contains both the original and the new\npath being renamed. In previous versions, it would even appear on some platforms as if the\noriginal always came before the new. However, none of this was true. It's impossible to\nreliably and portably know which changed path is the old or new, \"half\" renames may appear\n(only the original, only the new), \"unknown\" renames may appear (change was a rename, but\nwhether it was the old or new isn't known), rename events might split across two debouncing\nboundaries, and so on.\n\nThis option controls where that information is emitted. It defaults to 'none', which doesn't\nemit event information at all. The other options are 'environment' (deprecated), 'stdio',\n'file', 'json-stdio', and 'json-file'.\n\nThe 'stdio' and 'file' modes are text-based: 'stdio' writes absolute paths to the stdin of\nthe command, one per line, each prefixed with `create:`, `remove:`, `rename:`, `modify:`,\nor `other:`, then closes the handle; 'file' writes the same thing to a temporary file, and\nits path is given with the $WATCHEXEC_EVENTS_FILE environment variable.\n\nThere are also two JSON modes, which are based on JSON objects and can represent the full\nset of events Watchexec handles. Here's an example of a folder being created on Linux:\n\n```json\n  {\n    \"tags\": [\n      {\n        \"kind\": \"path\",\n        \"absolute\": \"/home/user/your/new-folder\",\n        \"filetype\": \"dir\"\n      },\n      {\n        \"kind\": \"fs\",\n        \"simple\": \"create\",\n        \"full\": \"Create(Folder)\"\n      },\n      {\n        \"kind\": \"source\",\n        \"source\": \"filesystem\",\n      }\n    ],\n    \"metadata\": {\n      \"notify-backend\": \"inotify\"\n    }\n  }\n```\n\nThe fields are as follows:\n\n  - `tags`, structured event data.\n  - `tags[].kind`, which can be:\n    * 'path', along with:\n      + `absolute`, an absolute path.\n      + `filetype`, a file type if known ('dir', 'file', 'symlink', 'other').\n    * 'fs':\n      + `simple`, the \"simple\" event type ('access', 'create', 'modify', 'remove', or 'other').\n      + `full`, the \"full\" event type, which is too complex to fully describe here, but looks like 'General(Precise(Specific))'.\n    * 'source', along with:\n      + `source`, the source of the event ('filesystem', 'keyboard', 'mouse', 'os', 'time', 'internal').\n    * 'keyboard', along with:\n      + `keycode`. Currently only the value 'eof' is supported.\n    * 'process', for events caused by processes:\n      + `pid`, the process ID.\n    * 'signal', for signals sent to Watchexec:\n      + `signal`, the normalised signal name ('hangup', 'interrupt', 'quit', 'terminate', 'user1', 'user2').\n    * 'completion', for when a command ends:\n      + `disposition`, the exit disposition ('success', 'error', 'signal', 'stop', 'exception', 'continued').\n      + `code`, the exit, signal, stop, or exception code.\n  - `metadata`, additional information about the event.\n\nThe 'json-stdio' mode will emit JSON events to the standard input of the command, one per\nline, then close stdin. The 'json-file' mode will create a temporary file, write the\nevents to it, and provide the path to the file with the $WATCHEXEC_EVENTS_FILE\nenvironment variable.\n\nFinally, the 'environment' mode was the default until 2.0. It sets environment variables\nwith the paths of the affected files, for filesystem events:\n\n$WATCHEXEC_COMMON_PATH is set to the longest common path of all of the below variables,\nand so should be prepended to each path to obtain the full/real path. Then:\n\n  - $WATCHEXEC_CREATED_PATH is set when files/folders were created\n  - $WATCHEXEC_REMOVED_PATH is set when files/folders were removed\n  - $WATCHEXEC_RENAMED_PATH is set when files/folders were renamed\n  - $WATCHEXEC_WRITTEN_PATH is set when files/folders were modified\n  - $WATCHEXEC_META_CHANGED_PATH is set when files/folders' metadata were modified\n  - $WATCHEXEC_OTHERWISE_CHANGED_PATH is set for every other kind of pathed event\n\nMultiple paths are separated by the system path separator, ';' on Windows and ':' on unix.\nWithin each variable, paths are deduplicated and sorted in binary order (i.e. neither\nUnicode nor locale aware).\n\nThis is the legacy mode, is deprecated, and will be removed in the future. The environment\nis a very restricted space, while also limited in what it can usefully represent. Large\nnumbers of files will either cause the environment to be truncated, or may error or crash\nthe process entirely. The $WATCHEXEC_COMMON_PATH is also unintuitive, as demonstrated by the\nmultiple confused queries that have landed in my inbox over the years."
        arg <MODE> {
            choices environment stdio file json-stdio json-file none
        }
    }
    flag --only-emit-events help="Only emit events to stdout, run no commands" {
        long_help "Only emit events to stdout, run no commands.\n\nThis is a convenience option for using Watchexec as a file watcher, without running any commands. It is almost equivalent to using `cat` as the command, except that it will not spawn a new process for each event.\n\nThis option requires `--emit-events-to` to be set, and restricts the available modes to `stdio` and `json-stdio`, modifying their behaviour to write to stdout instead of the stdin of the command."
    }
    flag "-E --env" help="Add env vars to the command" var=#true {
        long_help "Add env vars to the command\n\nThis is a convenience option for setting environment variables for the command, without setting them for the Watchexec process itself.\n\nUse key=value syntax. Multiple variables can be set by repeating the option."
        arg "<KEY=VALUE>"
    }
    flag --wrap-process help="Configure how the process is wrapped" {
        long_help "Configure how the process is wrapped\n\nBy default, Watchexec will run the command in a process group in Unix, and in a Job Object in Windows.\n\nSome Unix programs prefer running in a session, while others do not work in a process group.\n\nUse 'group' to use a process group, 'session' to use a process session, and 'none' to run the command directly. On Windows, either of 'group' or 'session' will use a Job Object."
        arg <MODE> {
            choices group session none
        }
    }
    flag "-N --notify" help="Alert when commands start and end" {
        long_help "Alert when commands start and end\n\nWith this, Watchexec will emit a desktop notification when a command starts and ends, on supported platforms. On unsupported platforms, it may silently do nothing, or log a warning."
    }
    flag --color help="When to use terminal colours" {
        long_help "When to use terminal colours\n\nSetting the environment variable `NO_COLOR` to any value is equivalent to `--color=never`."
        arg <MODE> {
            choices auto always never
        }
    }
    flag --timings help="Print how long the command took to run" {
        long_help "Print how long the command took to run\n\nThis may not be exactly accurate, as it includes some overhead from Watchexec itself. Use the `time` utility, high-precision timers, or benchmarking tools for more accurate results."
    }
    flag "-q --quiet" help="Don't print starting and stopping messages" {
        long_help "Don't print starting and stopping messages\n\nBy default Watchexec will print a message when the command starts and stops. This option disables this behaviour, so only the command's output, warnings, and errors will be printed."
    }
    flag --bell help="Ring the terminal bell on command completion"
    flag --project-origin help="Set the project origin" {
        long_help "Set the project origin\n\nWatchexec will attempt to discover the project's \"origin\" (or \"root\") by searching for a variety of markers, like files or directory patterns. It does its best but sometimes gets it it wrong, and you can override that with this option.\n\nThe project origin is used to determine the path of certain ignore files, which VCS is being used, the meaning of a leading '/' in filtering patterns, and maybe more in the future.\n\nWhen set, Watchexec will also not bother searching, which can be significantly faster."
        arg <DIRECTORY>
    }
    flag --workdir help="Set the working directory" {
        long_help "Set the working directory\n\nBy default, the working directory of the command is the working directory of Watchexec. You can change that with this option. Note that paths may be less intuitive to use with this."
        arg <DIRECTORY>
    }
    flag "-e --exts" help="Filename extensions to filter to" var=#true {
        long_help "Filename extensions to filter to\n\nThis is a quick filter to only emit events for files with the given extensions. Extensions can be given with or without the leading dot (e.g. 'js' or '.js'). Multiple extensions can be given by repeating the option or by separating them with commas."
        arg <EXTENSIONS>
    }
    flag "-f --filter" help="Filename patterns to filter to" var=#true {
        long_help "Filename patterns to filter to\n\nProvide a glob-like filter pattern, and only events for files matching the pattern will be emitted. Multiple patterns can be given by repeating the option. Events that are not from files (e.g. signals, keyboard events) will pass through untouched."
        arg <PATTERN>
    }
    flag --filter-file help="Files to load filters from" var=#true {
        long_help "Files to load filters from\n\nProvide a path to a file containing filters, one per line. Empty lines and lines starting with '#' are ignored. Uses the same pattern format as the '--filter' option.\n\nThis can also be used via the $WATCHEXEC_FILTER_FILES environment variable."
        arg <PATH>
    }
    flag "-J --filter-prog" help="[experimental] Filter programs" var=#true {
        long_help "[experimental] Filter programs.\n\n/!\\ This option is EXPERIMENTAL and may change and/or vanish without notice.\n\nProvide your own custom filter programs in jaq (similar to jq) syntax. Programs are given an event in the same format as described in '--emit-events-to' and must return a boolean. Invalid programs will make watchexec fail to start; use '-v' to see program runtime errors.\n\nIn addition to the jaq stdlib, watchexec adds some custom filter definitions:\n\n- 'path | file_meta' returns file metadata or null if the file does not exist.\n\n- 'path | file_size' returns the size of the file at path, or null if it does not exist.\n\n- 'path | file_read(bytes)' returns a string with the first n bytes of the file at path. If the file is smaller than n bytes, the whole file is returned. There is no filter to read the whole file at once to encourage limiting the amount of data read and processed.\n\n- 'string | hash', and 'path | file_hash' return the hash of the string or file at path. No guarantee is made about the algorithm used: treat it as an opaque value.\n\n- 'any | kv_store(key)', 'kv_fetch(key)', and 'kv_clear' provide a simple key-value store. Data is kept in memory only, there is no persistence. Consistency is not guaranteed.\n\n- 'any | printout', 'any | printerr', and 'any | log(level)' will print or log any given value to stdout, stderr, or the log (levels = error, warn, info, debug, trace), and pass the value through (so '[1] | log(\"debug\") | .[]' will produce a '1' and log '[1]').\n\nAll filtering done with such programs, and especially those using kv or filesystem access, is much slower than the other filtering methods. If filtering is too slow, events will back up and stall watchexec. Take care when designing your filters.\n\nIf the argument to this option starts with an '@', the rest of the argument is taken to be the path to a file containing a jaq program.\n\nJaq programs are run in order, after all other filters, and short-circuit: if a filter (jaq or not) rejects an event, execution stops there, and no other filters are run. Additionally, they stop after outputting the first value, so you'll want to use 'any' or 'all' when iterating, otherwise only the first item will be processed, which can be quite confusing!\n\nFind user-contributed programs or submit your own useful ones at <https://github.com/watchexec/watchexec/discussions/592>.\n\n## Examples:\n\nRegexp ignore filter on paths:\n\n'all(.tags[] | select(.kind == \"path\"); .absolute | test(\"[.]test[.]js$\")) | not'\n\nPass any event that creates a file:\n\n'any(.tags[] | select(.kind == \"fs\"); .simple == \"create\")'\n\nPass events that touch executable files:\n\n'any(.tags[] | select(.kind == \"path\" && .filetype == \"file\"); .absolute | metadata | .executable)'\n\nIgnore files that start with shebangs:\n\n'any(.tags[] | select(.kind == \"path\" && .filetype == \"file\"); .absolute | read(2) == \"#!\") | not'"
        arg <EXPRESSION>
    }
    flag "-i --ignore" help="Filename patterns to filter out" var=#true {
        long_help "Filename patterns to filter out\n\nProvide a glob-like filter pattern, and events for files matching the pattern will be excluded. Multiple patterns can be given by repeating the option. Events that are not from files (e.g. signals, keyboard events) will pass through untouched."
        arg <PATTERN>
    }
    flag --ignore-file help="Files to load ignores from" var=#true {
        long_help "Files to load ignores from\n\nProvide a path to a file containing ignores, one per line. Empty lines and lines starting with '#' are ignored. Uses the same pattern format as the '--ignore' option.\n\nThis can also be used via the $WATCHEXEC_IGNORE_FILES environment variable."
        arg <PATH>
    }
    flag --fs-events help="Filesystem events to filter to" var=#true {
        long_help "Filesystem events to filter to\n\nThis is a quick filter to only emit events for the given types of filesystem changes. Choose from 'access', 'create', 'remove', 'rename', 'modify', 'metadata'. Multiple types can be given by repeating the option or by separating them with commas. By default, this is all types except for 'access'.\n\nThis may apply filtering at the kernel level when possible, which can be more efficient, but may be more confusing when reading the logs."
        arg <EVENTS> {
            choices access create remove rename modify metadata
        }
    }
    flag --no-meta help="Don't emit fs events for metadata changes" {
        long_help "Don't emit fs events for metadata changes\n\nThis is a shorthand for '--fs-events create,remove,rename,modify'. Using it alongside the '--fs-events' option is non-sensical and not allowed."
    }
    flag --print-events help="Print events that trigger actions" {
        long_help "Print events that trigger actions\n\nThis prints the events that triggered the action when handling it (after debouncing), in a human readable form. This is useful for debugging filters.\n\nUse '-vvv' instead when you need more diagnostic information."
    }
    flag --manual help="Show the manual page" {
        long_help "Show the manual page\n\nThis shows the manual page for Watchexec, if the output is a terminal and the 'man' program is available. If not, the manual page is printed to stdout in ROFF format (suitable for writing to a watchexec.1 file)."
    }
    arg "[TASK]" help="Tasks to run\nCan specify multiple tasks by separating with `:::`\ne.g.: `mise run task1 arg1 arg2 ::: task2 arg1 arg2`" required=#false
    arg "[ARGS]..." help="Task and arguments to run" required=#false double_dash=automatic var=#true
}
cmd where help="Display the installation path for a tool" {
    long_help "Display the installation path for a tool\n\nThe tool must be installed for this to work."
    after_long_help "Examples:\n\n    # Show the latest installed version of node\n    # If it is is not installed, errors\n    $ mise where node@20\n    /home/jdx/.local/share/mise/installs/node/20.0.0\n\n    # Show the current, active install directory of node\n    # Errors if node is not referenced in any .tool-version file\n    $ mise where node\n    /home/jdx/.local/share/mise/installs/node/20.0.0\n"
    arg <TOOL@VERSION> help="Tool(s) to look up\ne.g.: ruby@3\nif \"@<PREFIX>\" is specified, it will show the latest installed version\nthat matches the prefix\notherwise, it will show the current, active installed version"
    arg "[ASDF_VERSION]" help="the version prefix to use when querying the latest version\nsame as the first argument after the \"@\"\nused for asdf compatibility" required=#false hide=#true
}
cmd which help="Shows the path that a tool's bin points to." {
    long_help "Shows the path that a tool's bin points to.\n\nUse this to figure out what version of a tool is currently active."
    after_long_help "Examples:\n\n    $ mise which node\n    /home/username/.local/share/mise/installs/node/20.0.0/bin/node\n\n    $ mise which node --plugin\n    node\n\n    $ mise which node --version\n    20.0.0\n"
    flag --complete hide=#true
    flag --plugin help="Show the plugin name instead of the path"
    flag --version help="Show the version instead of the path"
    flag "-t --tool" help="Use a specific tool@version\ne.g.: `mise which npm --tool=node@20`" {
        arg <TOOL@VERSION>
    }
    arg "[BIN_NAME]" help="The bin to look up" required=#false
}
cmd render-help hide=#true help="internal command to generate markdown from help"
cmd render-mangen hide=#true help="internal command to generate markdown from help"
source_code_link_template #"""
{%- set path = path | replace(from='-', to='_') -%}
{%- if cmd.subcommands | length > 0 -%}
{%- set path = path | split(pat="/") | slice(end=1) | concat(with="mod.rs") | join(sep="/") -%}
{%- else -%}
{%- set path = path ~ ".rs" -%}
{%- endif -%}
https://github.com/jdx/mise/blob/main/src/cli/{{path}}
"""#

complete "alias" run="mise alias ls {{words[PREV]}} | awk '{print $2}'"
complete "config_file" type="file"
complete "new_plugin" run="mise plugins --all"
complete "installed_tool" run="mise ls -i | awk '{print $1}' | uniq"
complete "plugin" run="mise plugins --core --user"
complete "prefix" run="mise ls-remote {{words[PREV]}}"
complete "setting" run="mise settings --complete" descriptions=#true
complete "task" run="mise tasks ls --complete" descriptions=#true
complete "tool" run="mise registry --complete" descriptions=#true
complete "env_var" run=#"mise set --complete | awk '{print $1"="}'"#
complete "env_key" run="mise set --complete"
complete "backend" run="mise backends"
complete "bin_name" run="mise which --complete"

complete "tool@version" run=#"""
cur="{{words[CURRENT]}}"
case $cur in
  *@*)
    tool="$(echo "$cur" | cut -d'@' -f1)"
    prefix="$(echo "$cur" | cut -d'@' -f2)"

    versions=$(mise ls-remote $tool $prefix | sed '1!G;h;$!d')

    for version in $versions; do
      echo "$tool@$version"
    done
    ;;
  *)
    plugins=$(mise registry | awk '{print $1}')
    for plugin in $plugins; do
      echo "$plugin@"
    done
    ;;
esac
"""#

complete "installed_tool@version" run=#"""
cur="{{words[CURRENT]}}"
case $cur in
  *@*)
    tool="$(echo "$cur" | cut -d'@' -f1)"
    prefix="$(echo "$cur" | cut -d'@' -f2)"

    if [ ! -z "$prefix" ]; then
      prefix="--prefix $prefix"
    fi
    versions=$(mise ls --installed $tool $prefix | awk '{print $2}' | sed '1!G;h;$!d')

    for version in $versions; do
      echo "$tool@$version"
    done
    ;;
  *)
    plugins=$(mise ls --installed | awk '{print $1}' | sed '1!G;h;$!d')
    for plugin in $plugins; do
      echo "$plugin@"
    done
    ;;
esac
"""#
