#!/usr/bin/env bash

# Test MCP protocol interactions in more detail
export MISE_EXPERIMENTAL=1

# Create a test environment with tools, tasks and env vars
cat >mise.toml <<EOF
[tools]
node = "20.11.0"
python = "3.12"

[env]
TEST_MCP_VAR = "test_value"
PROJECT_ENV = "development"
API_KEY = "secret123"

[tasks.test-task]
run = "echo 'Running test task'"
description = "A test task for MCP"

[tasks.build]
run = "echo 'Building...'"
description = "Build the project"
depends = ["test-task"]
alias = ["b"]
dir = "."
quiet = true

[tasks.lint]
run = "echo 'Linting code'"
description = "Run linters"
usage = "lint [files...]"
EOF

# Helper function to send JSON-RPC request to MCP server
send_mcp_request() {
	local method=$1
	local params=$2
	local id=${3:-1}

	local request="{\"jsonrpc\":\"2.0\",\"id\":$id,\"method\":\"$method\",\"params\":$params}"
	echo "$request"
}

# Helper to extract result from JSON-RPC response
extract_result() {
	local response=$1
	echo "$response" | grep -o '"result":[^}]*' | sed 's/"result"://'
}

echo "Testing MCP server startup and error handling..."

# Test that MCP server rejects invalid JSON
output=$(echo "not json" | mise mcp 2>&1 || true)
if [[ $output == *"Failed to create service"* ]]; then
	echo "SUCCESS: MCP server correctly rejected invalid JSON"
else
	echo "ERROR: Expected 'Failed to create service' in output, got: $output"
	exit 1
fi

echo -e "\nTesting MCP protocol with actual requests..."

# Create a script to interact with MCP server
cat >test_mcp.py <<'EOF'
#!/usr/bin/env python3
import json
import subprocess
import sys
from typing import Dict, Any

def send_request(proc, method: str, params: Dict[str, Any] = None, id: int = 1):
    """Send a JSON-RPC request to the MCP server"""
    request = {
        "jsonrpc": "2.0",
        "id": id,
        "method": method,
        "params": params or {}
    }
    
    request_str = json.dumps(request) + "\n"
    proc.stdin.write(request_str.encode())
    proc.stdin.flush()
    
    # Read response
    response_line = proc.stdout.readline().decode().strip()
    if response_line:
        return json.loads(response_line)
    return None

def main():
    # Determine mise binary path
    import shutil
    mise_path = shutil.which("mise")
    if not mise_path:
        # Try to use the built binary in the project
        import os
        alt_path = os.path.join(os.path.dirname(__file__), "..", "..", "..", "target", "debug", "mise")
        if os.path.exists(alt_path):
            mise_path = alt_path
        else:
            print("ERROR: Could not find mise binary")
            return 1
    
    print(f"Using mise binary: {mise_path}")
    
    # Kill any existing MCP processes that might interfere
    import signal
    try:
        subprocess.run(["pkill", "-f", "mise mcp"], capture_output=True)
    except:
        pass
    
    # Small delay to ensure processes are gone
    import time
    time.sleep(0.5)
    
    # Start MCP server
    proc = subprocess.Popen(
        [mise_path, "mcp"],
        stdin=subprocess.PIPE,
        stdout=subprocess.PIPE,
        stderr=subprocess.PIPE,
        env={**dict(environ), "MISE_EXPERIMENTAL": "1"}
    )
    
    try:
        # Initialize the connection
        print("Initializing MCP connection...")
        response = send_request(proc, "initialize", {
            "protocolVersion": "2024-11-05",
            "capabilities": {},
            "clientInfo": {"name": "test-client", "version": "1.0.0"}
        })
        
        if not response or "result" not in response:
            print(f"Failed to initialize: {response}")
            return 1
            
        server_info = response["result"]
        print(f"Server info: {json.dumps(server_info, indent=2)}")
        
        # Send initialized notification (required by MCP protocol)
        initialized_notification = {
            "jsonrpc": "2.0",
            "method": "initialized",
            "params": {}
        }
        notification_str = json.dumps(initialized_notification) + "\n"
        proc.stdin.write(notification_str.encode())
        proc.stdin.flush()
        print("Sent initialized notification")
        
        # Small delay to ensure server processes the notification
        import time
        time.sleep(0.1)
        
        # Check capabilities
        if "capabilities" not in server_info:
            print("ERROR: No capabilities in server info")
            return 1
            
        capabilities = server_info["capabilities"]
        print(f"Capabilities: {capabilities}")
        
        # The capabilities might be nested or differently structured
        if isinstance(capabilities.get("resources"), dict) and not capabilities["resources"]:
            # Empty dict means resources are enabled but with no specific settings
            print("Resources capability is enabled (empty dict)")
        elif not capabilities.get("resources"):
            print("ERROR: Resources capability not advertised")
            return 1
            
        # List resources
        print("\nListing resources...")
        response = send_request(proc, "resources/list", {}, id=2)
        if not response:
            print("Failed to list resources: No response received")
            # Try to read any error from stderr
            import select
            readable_err, _, _ = select.select([proc.stderr], [], [], 0.1)
            if readable_err:
                stderr = proc.stderr.read().decode()
                if stderr:
                    print("Stderr:", stderr)
            return 1
        elif "error" in response:
            print(f"Failed to list resources - Error: {response['error']}")
            return 1
        elif "result" not in response:
            print(f"Failed to list resources - Unexpected response: {response}")
            return 1
            
        resources = response["result"]["resources"]
        print(f"Available resources: {[r['uri'] for r in resources]}")
        
        # Expected resources
        expected_resources = ["mise://tools", "mise://tasks", "mise://env", "mise://config"]
        for uri in expected_resources:
            if not any(r["uri"] == uri for r in resources):
                print(f"ERROR: Expected resource {uri} not found")
                return 1
        
        # Read tools resource (default - only active tools)
        print("\nReading tools resource (default - active only)...")
        response = send_request(proc, "resources/read", {"uri": "mise://tools"})
        if not response or "result" not in response:
            print(f"Failed to read tools: {response}")
            return 1
            
        tools_content = response["result"]["contents"][0]
        if tools_content.get("mimeType") != "application/json":
            print(f"ERROR: Expected application/json, got {tools_content.get('mimeType')}")
            return 1
            
        tools_data = json.loads(tools_content["text"])
        print(f"Active tools found: {list(tools_data.keys())}")
        
        # Validate we have the expected tools and they're all active
        if tools_data:
            for tool_name, versions in tools_data.items():
                for version in versions:
                    if not version.get("active"):
                        print(f"ERROR: Found inactive tool in default query: {tool_name}@{version['version']}")
                        return 1
        
        # Read tools resource with inactive tools included
        print("\nReading tools resource (including inactive)...")
        response = send_request(proc, "resources/read", {"uri": "mise://tools?include_inactive=true"})
        if not response or "result" not in response:
            print(f"Failed to read tools with inactive: {response}")
            return 1
            
        tools_content_all = response["result"]["contents"][0]
        tools_data_all = json.loads(tools_content_all["text"])
        print(f"All tools found (active + inactive): {list(tools_data_all.keys())}")
        
        # Validate we have more tools when including inactive
        total_versions_active = sum(len(versions) for versions in tools_data.values())
        total_versions_all = sum(len(versions) for versions in tools_data_all.values())
        print(f"Active versions: {total_versions_active}, All versions: {total_versions_all}")
        
        # Validate we have the expected tools
        if "node" not in tools_data_all and "python" not in tools_data_all:
            print("WARNING: Expected tools (node, python) not found, might not be installed")
        
        # Read tasks resource
        print("\nReading tasks resource...")
        response = send_request(proc, "resources/read", {"uri": "mise://tasks"})
        if not response or "result" not in response:
            print(f"Failed to read tasks: {response}")
            return 1
            
        tasks_content = response["result"]["contents"][0]
        tasks_data = json.loads(tasks_content["text"])
        print(f"Tasks found: {len(tasks_data)} tasks")
        
        # Validate task data
        task_names = [t["name"] for t in tasks_data]
        for expected_task in ["test-task", "build", "lint"]:
            if expected_task not in task_names:
                print(f"ERROR: Expected task {expected_task} not found")
                return 1
        
        # Check build task details
        build_task = next((t for t in tasks_data if t["name"] == "build"), None)
        if build_task:
            if build_task["description"] != "Build the project":
                print(f"ERROR: Unexpected build task description: {build_task['description']}")
                return 1
            if "test-task" not in build_task.get("depends", []):
                print(f"ERROR: Build task should depend on test-task")
                return 1
            if "b" not in build_task.get("aliases", []):
                print(f"ERROR: Build task should have alias 'b'")
                return 1
            if not build_task.get("quiet"):
                print(f"ERROR: Build task should be quiet")
                return 1
        
        # Read env resource
        print("\nReading env resource...")
        response = send_request(proc, "resources/read", {"uri": "mise://env"})
        if not response or "result" not in response:
            print(f"Failed to read env: {response}")
            return 1
            
        env_content = response["result"]["contents"][0]
        env_data = json.loads(env_content["text"])
        print(f"Env vars found: {len(env_data)} variables")
        
        # Validate env vars
        for expected_var in ["TEST_MCP_VAR", "PROJECT_ENV", "API_KEY"]:
            if expected_var not in env_data:
                print(f"ERROR: Expected env var {expected_var} not found")
                return 1
        
        if env_data.get("TEST_MCP_VAR") != "test_value":
            print(f"ERROR: TEST_MCP_VAR has wrong value: {env_data.get('TEST_MCP_VAR')}")
            return 1
            
        # Read config resource
        print("\nReading config resource...")
        response = send_request(proc, "resources/read", {"uri": "mise://config"})
        if not response or "result" not in response:
            print(f"Failed to read config: {response}")
            return 1
            
        config_content = response["result"]["contents"][0]
        config_data = json.loads(config_content["text"])
        print(f"Config: {json.dumps(config_data, indent=2)}")
        
        # Test invalid resource
        print("\nTesting invalid resource...")
        response = send_request(proc, "resources/read", {"uri": "mise://invalid"})
        if response and "error" in response:
            print(f"Got expected error for invalid resource: {response['error']['message']}")
        else:
            print(f"ERROR: Expected error for invalid resource, got: {response}")
            return 1
        
        print("\nAll MCP protocol tests passed!")
        return 0
        
    finally:
        proc.terminate()
        proc.wait()

if __name__ == "__main__":
    from os import environ
    sys.exit(main())
EOF

# Run the Python test script
chmod +x test_mcp.py
python3 test_mcp.py || exit 1

# Clean up
rm -f test_mcp.py

echo "All tests completed successfully!"
