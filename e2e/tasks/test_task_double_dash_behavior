#!/usr/bin/env bash

# Test the new double-dash behavior setting

cat <<EOF >mise.toml
[tasks.echo_args]
run = 'echo "args:\$@"'
EOF

# Test 1: Unset (default) - should show deprecation warning when using --
unset MISE_TASK_DOUBLE_DASH_BEHAVIOR
assert_contains "mise run echo_args -- arg1 2>&1" "deprecated"
assert_contains "mise run echo_args -- arg1 2>&1" "task_double_dash"

# Test 1b: Legacy mode (explicit) - should NOT show deprecation warning
export MISE_TASK_DOUBLE_DASH_BEHAVIOR=legacy
assert_not_contains "mise run echo_args -- arg1 2>&1" "deprecated"
assert "mise run echo_args -q -- arg1" "args: arg1"

# Test 2: Separator mode - should NOT show deprecation warning, exact output
export MISE_TASK_DOUBLE_DASH_BEHAVIOR=separator
assert_not_contains "mise run echo_args -- arg1 2>&1" "deprecated"
assert "mise run echo_args -q -- arg1" "args: -- arg1"

# Test 3: Separator mode - multiple args after --
export MISE_TASK_DOUBLE_DASH_BEHAVIOR=separator
assert "mise run echo_args -q -- arg1 arg2 arg3" "args: -- arg1 arg2 arg3"

# Test 4: Separator mode - double double-dash passes through to task
export MISE_TASK_DOUBLE_DASH_BEHAVIOR=separator
assert "mise run echo_args -q -- -- arg1" "args: -- -- arg1"

# Test 5: No double-dash - no warning in either mode
unset MISE_TASK_DOUBLE_DASH_BEHAVIOR
assert_not_contains "mise run echo_args arg1 2>&1" "deprecated"

export MISE_TASK_DOUBLE_DASH_BEHAVIOR=legacy
assert_not_contains "mise run echo_args arg1 2>&1" "deprecated"

export MISE_TASK_DOUBLE_DASH_BEHAVIOR=separator
assert_not_contains "mise run echo_args arg1 2>&1" "deprecated"
assert "mise run echo_args -q arg1" "args: arg1"

# Test 6: Verify --help works correctly in separator mode
cat <<EOF >mise.toml
[tasks.echo_args]
run = 'echo "args:\$@"'

[tasks.show_help]
run = 'echo "help flag received:\$@"'
EOF

export MISE_TASK_DOUBLE_DASH_BEHAVIOR=separator
assert "mise run show_help -q -- --help" "help flag received: -- --help"

# Test 7: Naked runs (without 'run' subcommand) - Unset (default)
unset MISE_TASK_DOUBLE_DASH_BEHAVIOR
assert_contains "mise echo_args -- arg1 2>&1" "deprecated"
assert_contains "mise echo_args -- arg1 2>&1" "task_double_dash"

# Test 7b: Naked runs - Legacy mode (explicit) - no warning
export MISE_TASK_DOUBLE_DASH_BEHAVIOR=legacy
assert_not_contains "mise echo_args -- arg1 2>&1" "deprecated"
assert "mise echo_args -q -- arg1" "args: arg1"

# Test 8: Naked runs - Separator mode, exact output
export MISE_TASK_DOUBLE_DASH_BEHAVIOR=separator
assert_not_contains "mise echo_args -- arg1 2>&1" "deprecated"
assert "mise echo_args -q -- arg1" "args: -- arg1"

# Test 9: Naked runs - multiple args after --
export MISE_TASK_DOUBLE_DASH_BEHAVIOR=separator
assert "mise echo_args -q -- arg1 arg2 arg3" "args: -- arg1 arg2 arg3"

# Test 10: Naked runs - double double-dash passes through
export MISE_TASK_DOUBLE_DASH_BEHAVIOR=separator
assert "mise echo_args -q -- -- arg1" "args: -- -- arg1"

# Test 11: Naked runs - --help in separator mode
export MISE_TASK_DOUBLE_DASH_BEHAVIOR=separator
assert "mise show_help -q -- --help" "help flag received: -- --help"

# Test 12: Naked runs - no double-dash, no warning (with explicit legacy mode)
export MISE_TASK_DOUBLE_DASH_BEHAVIOR=legacy
assert_not_contains "mise echo_args arg1 2>&1" "deprecated"
assert "mise -q echo_args arg1" "args: arg1"

# Test 13: Naked runs - no double-dash, no warning (with separator mode)
export MISE_TASK_DOUBLE_DASH_BEHAVIOR=separator
assert_not_contains "mise echo_args arg1 2>&1" "deprecated"
assert "mise -q echo_args arg1" "args: arg1"

# Test 14: Task with custom -q flag (legacy mode)
cat <<'EOF' >mise.toml
[tasks.custom_quiet]
run = '''
#!/usr/bin/env bash
while getopts "q" opt; do
  case $opt in
    q) echo "custom quiet flag received" ;;
  esac
done
'''
EOF

export MISE_TASK_DOUBLE_DASH_BEHAVIOR=legacy
# In legacy mode with explicit --, the flag is passed to the task
assert "mise run custom_quiet -- -q" "custom quiet flag received"
# In naked run, -q after task name is passed to task
assert "mise custom_quiet -q" "custom quiet flag received"

# Test 15: Task with custom -q flag (separator mode)
export MISE_TASK_DOUBLE_DASH_BEHAVIOR=separator
# In separator mode with explicit --, the task needs to handle the -- separator
cat <<'EOF' >mise.toml
[tasks.custom_quiet_separator]
run = '''
#!/usr/bin/env bash
# Skip the -- separator if present
if [ "$1" = "--" ]; then
  shift
fi
while getopts "q" opt; do
  case $opt in
    q) echo "custom quiet flag received" ;;
  esac
done
'''
EOF

assert "mise run custom_quiet_separator -- -q" "custom quiet flag received"
# In naked run, -q after task name is passed to task (no -- injected for flags)
assert "mise custom_quiet_separator -q" "custom quiet flag received"

# Test 16: Verify mise's own -q still works when placed before task name
export MISE_TASK_DOUBLE_DASH_BEHAVIOR=separator
# mise's -q should suppress output, task should receive no args
cat <<'EOF' >mise.toml
[tasks.check_args]
run = '''
#!/usr/bin/env bash
if [ $# -eq 0 ]; then
  echo "no args received"
else
  echo "args: $@"
fi
'''
EOF

assert "mise -q check_args" "no args received"
assert "mise check_args -q" "args: -q"

# Test 17: Task with usage spec shows help correctly
cat <<'EOF' >mise.toml
[tasks.with_usage]
run = 'echo "running with_usage: $@"'
usage = """
flag "-q --quiet" help="Suppress output"
arg "<file>" help="File to process"
"""
EOF

# Test --help shows usage information (--help exits with status 1, so use || true)
export MISE_TASK_DOUBLE_DASH_BEHAVIOR=legacy
output=$(mise run with_usage --help 2>&1 || true)
[[ $output == *"Usage: with_usage"* ]] || (echo "Expected 'Usage: with_usage' in output" && exit 1)
[[ $output == *"-q --quiet"* ]] || (echo "Expected '-q --quiet' in output" && exit 1)
[[ $output == *"<file>"* ]] || (echo "Expected '<file>' in output" && exit 1)

export MISE_TASK_DOUBLE_DASH_BEHAVIOR=separator
output=$(mise run with_usage --help 2>&1 || true)
[[ $output == *"Usage: with_usage"* ]] || (echo "Expected 'Usage: with_usage' in output" && exit 1)
[[ $output == *"-q --quiet"* ]] || (echo "Expected '-q --quiet' in output" && exit 1)
[[ $output == *"<file>"* ]] || (echo "Expected '<file>' in output" && exit 1)

# Test that naked run also shows help
output=$(mise with_usage --help 2>&1 || true)
[[ $output == *"Usage: with_usage"* ]] || (echo "Expected 'Usage: with_usage' in naked run" && exit 1)

# Test 18: Verify separator mode passes -- with --help
export MISE_TASK_DOUBLE_DASH_BEHAVIOR=separator
# When using explicit --, help should be passed to the task as a regular arg
cat <<'EOF' >mise.toml
[tasks.check_help_arg]
run = '''
#!/usr/bin/env bash
if [ "$1" = "--" ] && [ "$2" = "--help" ]; then
  echo "received -- --help as args"
elif [ "$1" = "--help" ]; then
  echo "received --help directly"
else
  echo "received: $@"
fi
'''
EOF

# In separator mode with explicit --, --help is passed as an argument
assert "mise run check_help_arg -- --help" "received -- --help as args"
