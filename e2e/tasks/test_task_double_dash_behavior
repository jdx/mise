#!/usr/bin/env bash

# Test smart flag routing: mise flags go to mise, unknown flags go to task, -- passes everything to task

cat <<'EOF' >mise.toml
[tasks.echo_args]
run = 'echo "args:$@"'
EOF

# Test 1: Mise flags work anywhere before --
# -q is a mise flag, so it should suppress output regardless of position
assert "mise run -q echo_args arg1 2>&1" "args: arg1"
assert "mise run echo_args -q arg1 2>&1" "args: arg1"
assert "mise -q run echo_args arg1 2>&1" "args: arg1"

# Test 2: Naked runs - mise flags still go to mise
assert "mise -q echo_args arg1 2>&1" "args: arg1"
assert "mise echo_args -q arg1 2>&1" "args: arg1"

# Test 3: Unknown flags go to task
cat <<'EOF' >mise.toml
[tasks.echo_args]
run = 'echo "args:$@"'
EOF

assert "mise run echo_args -x" "args: -x"
assert "mise run echo_args --custom" "args: --custom"
assert "mise echo_args -x" "args: -x"
assert "mise echo_args --custom" "args: --custom"

# Test 4: Explicit -- separator passes args to task (no prefix!)
assert "mise run echo_args -- -q" "args: -q"
assert "mise run echo_args -- --help" "args: --help"
assert "mise echo_args -- -q" "args: -q"
assert "mise echo_args -- --help" "args: --help"

# Test 5: Multiple args after --
assert "mise run echo_args -- arg1 arg2 arg3" "args: arg1 arg2 arg3"
assert "mise echo_args -- arg1 arg2 arg3" "args: arg1 arg2 arg3"

# Test 6: Mixed flags and args work correctly
assert "mise run -q echo_args -x arg1" "args: -x arg1"
assert "mise -q echo_args --custom arg1" "args: --custom arg1"

# Test 7: Task with usage spec
cat <<'EOF' >mise.toml
[tasks.with_usage]
run = 'echo "running with_usage: $@"'
usage = """
flag "-x --custom" help="Custom flag"
arg "<file>" help="File to process"
"""
EOF

# Usage spec handles its own flags (parsed by usage spec, not passed as $@)
assert "mise run with_usage -x myfile 2>&1" '[with_usage] $ echo "running with_usage: $@"
running with_usage: '

# But mise flags still go to mise (myfile is consumed by usage spec, not passed to $@)
assert "mise run -q with_usage myfile" "running with_usage: "

# Test 8: --help shows usage spec help
assert "mise run with_usage --help 2>&1 || true" "Usage: with_usage [-x --custom] <file>

Arguments:
  <file>
    File to process

Flags:
  -x --custom
    Custom flag"

# Test 9: Help passed as explicit argument with -- (recreate echo_args task)
cat <<'EOF' >mise.toml
[tasks.echo_args]
run = 'echo "args:$@"'
EOF

assert "mise run echo_args -- --help" "args: --help"

# Test 10: Tasks can use mise flags explicitly with --
cat <<'EOF' >mise.toml
[tasks.custom_quiet]
run = '''
#!/usr/bin/env bash
while getopts "q" opt; do
  case $opt in
    q) echo "custom quiet flag received" ;;
  esac
done
'''
EOF

# Task can receive -q via --
assert "mise run custom_quiet -- -q" "custom quiet flag received"
assert "mise custom_quiet -- -q" "custom quiet flag received"

# But without --, -q goes to mise
assert "mise run custom_quiet -q 2>&1 | grep -v '^\\[' || true" ""

# Test 11: Complex scenarios
cat <<'EOF' >mise.toml
[tasks.complex]
run = 'echo "received: $@"'
EOF

# Multiple mise flags + task args
assert "mise run -q complex arg1 arg2" "received:  arg1 arg2"

# Mix of mise flags and unknown flags
assert "mise run -q complex -x -y" "received:  -x -y"

# Explicit -- overrides everything
assert "mise run complex -- -q -v arg1" "received:  -q -v arg1"
